"use strict";const t=t=>typeof t,a="tinybase",e="",n=",",s=t(e),r=Promise,i=clearInterval,o=t=>null==t,c=(t,a,e)=>o(t)?e?.():a(t),l=a=>t(a)==s,E=t=>Array.isArray(t),w=(t,a,e)=>t.slice(a,e),y=t=>t.length,u=async t=>r.all(t),d=t=>{throw Error(t)},R=(t,a)=>t.forEach(a),A=(t,a="")=>t.join(a),T=(t,a)=>t.map(a),N=t=>0==y(t),g=(t,a)=>t.filter(a),p=(t,...a)=>t.push(...a),O=t=>t.shift(),$=Object,m=t=>$.getPrototypeOf(t),C=$.entries,v=$.keys,S=$.freeze,L=(t=[])=>$.fromEntries(t),I=(...t)=>$.assign({},...t),_=(t,a)=>(delete t[a],t),h=(t,a)=>T(C(t),(([t,e])=>a(e,t))),b=(t,a)=>L(h(t,((t,e)=>[e,a(t,e)]))),f=t=>$.values(t),D=t=>y(v(t)),P=t=>(t=>!o(t)&&c(m(t),(t=>t==$.prototype||o(m(t))),(()=>!0)))(t)&&0==D(t),M=(t,a)=>t?.has(a)??!1,F=t=>o(t)||0==(t=>t?.size??0)(t),U=t=>[...t?.values()??[]],G=(t,a)=>t?.forEach(a),B=(t,a)=>t?.delete(a),x=t=>new Map(t),j=(t,a)=>t?.get(a),Y=(t,a)=>T([...t?.entries()??[]],(([t,e])=>a(e,t))),q=(t,a,e)=>o(e)?(B(t,a),t):t?.set(a,e),H=(t,a,e,n)=>(M(t,a)?n?.(j(t,a)):q(t,a,e()),j(t,a)),X=(t,a,e,n,s=0)=>c((e?H:j)(t,a[s],s>y(a)-2?e:x),(r=>{if(s>y(a)-2)return n?.(r)&&q(t,a[s]),r;const i=X(r,a,e,n,s+1);return F(r)&&q(t,a[s]),i})),J=t=>new Set(E(t)||o(t)?t:[t]),W=(t,a)=>t?.add(a),k=/^\d+$/,z=x(),K=x(),V=(t,a,n,s,r,i,l,w={},u=0,A=[])=>{let T,N,g,$=0,m=0,C=0;H(z,A,(()=>0)),H(K,A,(()=>[]));const v=x(),[L,I,_,h,b]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!P(t)||!P(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!P(t)||!P(a),a.setContent]:d("Store type not supported by this Persister"))(l,t,u),[f,D,M]=(()=>{let t;const[a,n]=(()=>{const t=[];let a=0;return[n=>(n?O(t):null)??e+a++,a=>{k.test(a)&&y(t)<1e3&&p(t,a)}]})(),s=x();return[(n,r,i,o=[],c=()=>[])=>{t??=et;const l=a(1);return q(s,l,[n,r,i,o,c]),W(X(r,i??[e],J),l),l},(a,n,...r)=>R(((t,a=[e])=>{const n=[],s=(t,e)=>e==y(a)?p(n,t):null===a[e]?G(t,(t=>s(t,e+1))):R([a[e],null],(a=>s(j(t,a),e+1)));return s(t,0),n})(a,n),(a=>G(a,(a=>j(s,a)[0](t,...n??[],...r))))),t=>c(j(s,t),(([,a,r])=>(X(a,r??[e],void 0,(a=>(B(a,t),F(a)?1:0))),q(s,t),n(t),r))),a=>c(j(s,a),(([a,,e=[],n,s])=>{const r=(...i)=>{const c=y(i);c==y(e)?a(t,...i,...s(i)):o(e[c])?R(n[c]?.(...i)??[],(t=>r(...i,t))):r(...i,e[c])};r()}))]})(),U=t=>{t!=$&&($=t,D(v,void 0,$))},Y=a=>{(L&&E(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},V=async t=>(2!=$&&(U(1),m++,await at((async()=>{try{const e=await a();E(e)?Y(e):t?b(t):d("Content is not an array: "+e)}catch(a){i?.(a),t&&b(t)}U(0)}))),et),Q=()=>(N&&(r(N),N=void 0),et),Z=async t=>(1!=$&&(U(2),C++,await at((async()=>{try{await n(I,t)}catch(t){i?.(t)}U(0)}))),et),tt=()=>(g&&(t.delListener(g),g=void 0),et),at=async(...t)=>(p(j(K,A),...t),await(async()=>{if(!j(z,A)){for(q(z,A,1);!o(T=O(j(K,A)));)try{await T()}catch(t){i?.(t)}q(z,A,0)}})(),et),et={load:V,startAutoLoad:async t=>{Q(),await V(t);try{N=await s((async(t,a)=>{a||t?2!=$&&(U(1),m++,Y(a??t),U(0)):await V()}))}catch(t){i?.(t)}return et},stopAutoLoad:Q,isAutoLoading:()=>!o(N),save:Z,startAutoSave:async()=>(tt(),await Z(),g=t.addDidFinishTransactionListener((()=>{const t=_();h(t)&&Z(t)})),et),stopAutoSave:tt,isAutoSaving:()=>!o(g),getStatus:()=>$,addStatusListener:t=>f(t,v),delListener:a=>(M(a),t),schedule:at,getStore:()=>t,destroy:()=>(j(K,A).splice(0,void 0),Q().stopAutoSave()),getStats:()=>({loads:m,saves:C}),...w};return S(et)},Q="_",Z="_id",tt="SELECT",at="WHERE",et="TABLE",nt="ALTER "+et,st="DELETE FROM",rt=tt+"*FROM",it="pragma_",ot="data_version",ct="schema_version",lt="pragma_table_",Et=(t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t,wt=t=>`"${t.replace(/"/g,'""')}"`,yt=(t,a=[1])=>A(T(t,(()=>"$"+a[0]++)),n),ut=JSON.stringify,dt=JSON.parse,Rt=(t,a,e,s,r,i=At,c,l)=>{const E=x();return[async()=>{E.clear(),T(await e(t,a),(({tn:t,cn:a})=>W(H(E,t,J),a)))},async(a,e)=>((t,a)=>M(j(E,t),a))(a,e)?L(g(T(await t(rt+wt(a)),(t=>[t[e],l?b(_(t,e),l):_(t,e)])),(([t,a])=>!o(t)&&!P(a)))):{},async(a,e,s,l,w,y=!1)=>{const d=J();b(s??{},(t=>T(v(t??{}),(t=>W(d,t)))));const R=U(d);if(!y&&w&&N(R)&&M(E,a))return await t("DROP "+et+wt(a)),void q(E,a);const O=j(E,a),$=J(U(O));if(N(R)||(M(E,a)?await u(T([e,...R],(async(n,s)=>{B($,n)||(await t(nt+wt(a)+"ADD"+wt(n)+r),0==s&&await t("CREATE UNIQUE INDEX pk ON "+wt(a)+`(${wt(e)})`),W(O,n))}))):(await t("CREATE "+et+wt(a)+`(${wt(e)}${r} PRIMARY KEY${A(T(R,(t=>n+wt(t)+r)))});`),q(E,a,J([e,...R])))),await u([...!y&&l?T(U($),(async n=>{n!=e&&(await t(nt+wt(a)+"DROP"+wt(n)),B(O,n))})):[]]),y)o(s)?await t(st+wt(a)+at+" true"):await u(h(s,(async(n,s)=>{o(n)?await t(st+wt(a)+at+wt(e)+"=$1",[s]):N(R)||await i(t,a,e,v(n),{[s]:c?T(f(n),c):f(n)},O)})));else if(N(R))M(E,a)&&await t(st+wt(a)+at+" true");else{const n=g(U(j(E,a)),(t=>t!=e)),r={},o=[];b(s??{},((t,a)=>{r[a]=T(n,(a=>c?c(t?.[a]):t?.[a])),p(o,a)})),await i(t,a,e,n,r),await t(st+wt(a)+at+wt(e)+`NOT IN(${yt(o)})`,o)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){s?.(t)}return await t("END"),e}]},At=async(t,a,e,s,r)=>{const i=[1];await t("INSERT INTO"+wt(a)+"("+((...t)=>A(T(t,wt),n))(e,...s)+")VALUES"+A(h(r,(t=>"($"+i[0]+++","+yt(t,i)+")")),n)+"ON CONFLICT("+wt(e)+")DO UPDATE SET"+A(T(s,(t=>wt(t)+"=excluded."+wt(t))),n),h(r,((t,a)=>[a,...T(t,(t=>t??null))])).flat())},Tt=(t,a,e,n,s,r,i,[o,c,l],E,w,y,u,d,R)=>{const[A,T,N,g]=Rt(a,E,w,s,d,R),p=V(t,(async()=>await g((async()=>{return await A(),t=(await T(o,c))[Q]?.[l]??"null",dt(t,((t,a)=>"￼"===a?void 0:a));var t}))),(async t=>await g((async()=>{var a;await A(),await N(o,c,{[Q]:{[l]:(a=t()??null,ut(a,((t,a)=>void 0===a?"￼":a)))}},!0,!0)}))),e,n,s,i,{[u]:()=>y,destroy:()=>(p.stopAutoLoad().stopAutoSave(),r(),p)},0,y);return p},Nt=(t,a,e,n,s,r,i,[c,l,[E,w,y]],d,R,A,T,N,p,O,$)=>{const[m,C,v,S]=Rt(a,d,R,s,N,p,O,$),I=async(t,a)=>await u(Y(l,(async([e,n,s,r],i)=>{a&&!(i in t)||await v(e,n,t[i],s,r,a)}))),_=async(t,a)=>w?await v(y,Z,{[Q]:t},!0,!0,a):null,h=V(t,(async()=>await S((async()=>{await m();const t=await(async()=>L(g(await u(Y(c,(async([t,a],e)=>[t,await C(e,a)]))),(t=>!P(t[1])))))(),a=await(async()=>E?(await C(y,Z))[Q]:{})();return P(t)&&o(a)?void 0:[t,a]}))),(async(t,a)=>await S((async()=>{if(await m(),o(a)){const[a,e]=t();await I(a),await _(e)}else await I(a[0],!0),await _(a[1],!0)}))),e,n,s,i,{[T]:()=>A,destroy:()=>(h.stopAutoLoad().stopAutoSave(),r(),h)},0,A);return h},gt="ColumnName",pt="store",Ot="json",$t=pt+"TableName",mt=pt+"Id"+gt,Ct=pt+gt,vt="autoLoadIntervalSeconds",St="rowId"+gt,Lt="tableId",It="tableName",_t="deleteEmptyColumns",ht="deleteEmptyTable",bt={mode:Ot,[vt]:1},ft={load:0,save:0,[It]:a+"_values"},Dt=(t,a,e,n,s)=>{const r=x();return b(t,((t,i)=>{const c=w(f(I(a,l(t)?{[e]:t}:t)),0,D(a));o(c[0])||n(i,c[0])||(s(i,c[0]),q(r,i,c))})),r},Pt=t=>{const e=(t=>I(bt,l(t)?{[$t]:t}:t??{}))(t),n=e[vt];if(e.mode==Ot){const t=e[$t]??a;return[1,n,[t,e[mt]??Z,e[Ct]??pt],J(t)]}const{tables:{load:s={},save:r={}}={},values:i={}}=e,o=w(f(I(ft,i)),0,D(ft)),c=o[2],E=J(c),y=J(c);return[0,n,[Dt(s,{[Lt]:null,[St]:Z},Lt,(t=>M(y,t)),(t=>W(E,t))),Dt(r,{[It]:null,[St]:Z,[_t]:0,[ht]:0},It,((t,a)=>M(y,a)),((t,a)=>W(E,a))),o],E]},Mt=a,Ft=/^([cd]:)(.+)/,Ut=a+"_data",Gt=a+"_table";exports.Persists={StoreOnly:1,MergeableStoreOnly:2,StoreOrMergeableStore:3},exports.Status={Idle:0,Loading:1,Saving:2},exports.createCustomPersister=V,exports.createCustomPostgreSqlPersister=(t,a,e,n,s,r,i,o,l,E,w="getDb")=>{const y=Et(e,r),[d,,R,A]=Pt(a),N=async t=>{await y(`CREATE OR REPLACE TRIGGER ${wt(Ut+"_"+t)} AFTER INSERT OR UPDATE OR DELETE ON ${wt(t)} EXECUTE FUNCTION ${Ut}()`)};return(d?Tt:Nt)(t,y,(async t=>{await y(`CREATE OR REPLACE FUNCTION ${Gt}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Mt}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await y(`CREATE EVENT TRIGGER ${Gt} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${Gt}();`)}catch{}return await y(`CREATE OR REPLACE FUNCTION ${Ut}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Mt}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await u(T(U(A),(async t=>{await y(`CREATE TABLE IF NOT EXISTS ${wt(t)}("_id"text PRIMARY KEY)`),await N(t)}))),await n(Mt,(async a=>{return await c((e=a,n=Ft,e?.match(n)),(async([,a,e])=>{M(A,e)&&("c:"==a&&await N(e),t())}));var e,n}))}),s,i,o,l,R,U(A),(async(t,a)=>await t(`${tt} table_name tn,column_name cn FROM information_schema.columns ${at} table_schema='public'AND table_name IN(${yt(a)})`,a)),E,w,"text",void 0,(t=>ut(t)),(t=>dt(t)))},exports.createCustomSqlitePersister=(t,a,n,s,r,o,c,l,E,w,y="getDb",u)=>{let d,R,A;const T=Et(n,o),[N,g,p,O]=Pt(a);return(N?Tt:Nt)(t,T,(t=>{let a;const e=()=>a=setInterval((async()=>{try{const[{d:a,s:e,c:n}]=await T(`${tt} ${ot} d,${ct} s,TOTAL_CHANGES() c FROM ${it}${ot} JOIN ${it}${ct}`);a==d&&e==R&&n==A||(null!=d&&t(),d=a,R=e,A=n)}catch{}}),1e3*g),n=()=>{d=R=A=null,i(a)},o=s((a=>{O.has(a)&&(n(),t(),e())}));return e(),()=>{n(),r(o)}}),(t=>t()),c,l,E,p,U(O),(async(t,a)=>await t(`${tt} t.name tn,c.name cn FROM ${lt}list()t,${lt}info(t.name)c ${at} t.schema='main'AND t.type IN('table','view')AND t.name IN(${yt(a)})ORDER BY t.name,c.name`,a)),w,y,e,u,(t=>!0===t?1:!1===t?0:t),void 0)};
