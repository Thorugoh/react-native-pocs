"use strict";const a=a=>typeof a,t="tinybase",e="",n=",",s=a(e),i=Promise,r=clearInterval,o=a=>null==a,c=(a,t,e)=>o(a)?e?.():t(a),l=t=>a(t)==s,w=a=>Array.isArray(a),y=(a,t,e)=>a.slice(t,e),u=a=>a.length,d=async a=>i.all(a),p=a=>{throw Error(a)},v=(a,t)=>a.forEach(t),E=(a,t="")=>a.join(t),g=(a,t)=>a.map(t),A=a=>0==u(a),m=(a,t)=>a.filter(t),h=(a,...t)=>a.push(...t),N=a=>a.shift(),$="_",S="_id",f="SELECT",C="WHERE",O="TABLE",T="ALTER "+O,I="DELETE FROM",L=f+"*FROM",b="pragma_",D="data_version",R="schema_version",M="pragma_table_",_=a=>`"${a.replace(/"/g,'""')}"`,P=(a,t=[1])=>E(g(a,(()=>"$"+t[0]++)),n),F=(a,t)=>a?.has(t)??!1,U=a=>o(a)||0==(a=>a?.size??0)(a),j=a=>[...a?.values()??[]],x=(a,t)=>a?.forEach(t),B=(a,t)=>a?.delete(t),J=Object,Y=a=>J.getPrototypeOf(a),k=J.entries,z=J.keys,G=J.freeze,H=(a=[])=>J.fromEntries(a),W=(...a)=>J.assign({},...a),q=(a,t)=>(delete a[t],a),K=(a,t)=>g(k(a),(([a,e])=>t(e,a))),Q=(a,t)=>H(K(a,((a,e)=>[e,t(a,e)]))),V=a=>J.values(a),X=a=>u(z(a)),Z=a=>(a=>!o(a)&&c(Y(a),(a=>a==J.prototype||o(Y(a))),(()=>!0)))(a)&&0==X(a),aa=JSON.stringify,ta=JSON.parse,ea=a=>new Map(a),na=(a,t)=>a?.get(t),sa=(a,t)=>g([...a?.entries()??[]],(([a,e])=>t(e,a))),ia=(a,t,e)=>o(e)?(B(a,t),a):a?.set(t,e),ra=(a,t,e,n)=>(F(a,t)?n?.(na(a,t)):ia(a,t,e()),na(a,t)),oa=(a,t,e,n,s=0)=>c((e?ra:na)(a,t[s],s>u(t)-2?e:ea),(i=>{if(s>u(t)-2)return n?.(i)&&ia(a,t[s]),i;const r=oa(i,t,e,n,s+1);return U(i)&&ia(a,t[s]),r})),ca=a=>new Set(w(a)||o(a)?a:[a]),la=(a,t)=>a?.add(t),wa=/^\d+$/,ya=ea(),ua=ea(),da=(a,t,n,s,i,r,l,y={},d=0,E=[])=>{let g,A,m,$=0,S=0,f=0;ra(ya,E,(()=>0)),ra(ua,E,(()=>[]));const C=ea(),[O,T,I,L,b]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!Z(a)||!Z(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!Z(a)||!Z(t),t.setContent]:p("Store type not supported by this Persister"))(l,a,d),[D,R,M]=(()=>{let a;const[t,n]=(()=>{const a=[];let t=0;return[n=>(n?N(a):null)??e+t++,t=>{wa.test(t)&&u(a)<1e3&&h(a,t)}]})(),s=ea();return[(n,i,r,o=[],c=()=>[])=>{a??=z;const l=t(1);return ia(s,l,[n,i,r,o,c]),la(oa(i,r??[e],ca),l),l},(t,n,...i)=>v(((a,t=[e])=>{const n=[],s=(a,e)=>e==u(t)?h(n,a):null===t[e]?x(a,(a=>s(a,e+1))):v([t[e],null],(t=>s(na(a,t),e+1)));return s(a,0),n})(t,n),(t=>x(t,(t=>na(s,t)[0](a,...n??[],...i))))),a=>c(na(s,a),(([,t,i])=>(oa(t,i??[e],void 0,(t=>(B(t,a),U(t)?1:0))),ia(s,a),n(a),i))),t=>c(na(s,t),(([t,,e=[],n,s])=>{const i=(...r)=>{const c=u(r);c==u(e)?t(a,...r,...s(r)):o(e[c])?v(n[c]?.(...r)??[],(a=>i(...r,a))):i(...r,e[c])};i()}))]})(),_=a=>{a!=$&&($=a,R(C,void 0,$))},P=t=>{(O&&w(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},F=async a=>(2!=$&&(_(1),S++,await k((async()=>{try{const e=await t();w(e)?P(e):a?b(a):p("Content is not an array: "+e)}catch(t){r?.(t),a&&b(a)}_(0)}))),z),j=()=>(A&&(i(A),A=void 0),z),J=async a=>(1!=$&&(_(2),f++,await k((async()=>{try{await n(T,a)}catch(a){r?.(a)}_(0)}))),z),Y=()=>(m&&(a.delListener(m),m=void 0),z),k=async(...a)=>(h(na(ua,E),...a),await(async()=>{if(!na(ya,E)){for(ia(ya,E,1);!o(g=N(na(ua,E)));)try{await g()}catch(a){r?.(a)}ia(ya,E,0)}})(),z),z={load:F,startAutoLoad:async a=>{j(),await F(a);try{A=await s((async(a,t)=>{t||a?2!=$&&(_(1),S++,P(t??a),_(0)):await F()}))}catch(a){r?.(a)}return z},stopAutoLoad:j,isAutoLoading:()=>!o(A),save:J,startAutoSave:async()=>(Y(),await J(),m=a.addDidFinishTransactionListener((()=>{const a=I();L(a)&&J(a)})),z),stopAutoSave:Y,isAutoSaving:()=>!o(m),getStatus:()=>$,addStatusListener:a=>D(a,C),delListener:t=>(M(t),a),schedule:k,getStore:()=>a,destroy:()=>(na(ua,E).splice(0,void 0),j().stopAutoSave()),getStats:()=>({loads:S,saves:f}),...y};return G(z)},pa=(a,t,e,s,i,r=va,c,l)=>{const w=ea();return[async()=>{w.clear(),g(await e(a,t),(({tn:a,cn:t})=>la(ra(w,a,ca),t)))},async(t,e)=>((a,t)=>F(na(w,a),t))(t,e)?H(m(g(await a(L+_(t)),(a=>[a[e],l?Q(q(a,e),l):q(a,e)])),(([a,t])=>!o(a)&&!Z(t)))):{},async(t,e,s,l,y,u=!1)=>{const p=ca();Q(s??{},(a=>g(z(a??{}),(a=>la(p,a)))));const v=j(p);if(!u&&y&&A(v)&&F(w,t))return await a("DROP "+O+_(t)),void ia(w,t);const N=na(w,t),$=ca(j(N));if(A(v)||(F(w,t)?await d(g([e,...v],(async(n,s)=>{B($,n)||(await a(T+_(t)+"ADD"+_(n)+i),0==s&&await a("CREATE UNIQUE INDEX pk ON "+_(t)+`(${_(e)})`),la(N,n))}))):(await a("CREATE "+O+_(t)+`(${_(e)}${i} PRIMARY KEY${E(g(v,(a=>n+_(a)+i)))});`),ia(w,t,ca([e,...v])))),await d([...!u&&l?g(j($),(async n=>{n!=e&&(await a(T+_(t)+"DROP"+_(n)),B(N,n))})):[]]),u)o(s)?await a(I+_(t)+C+" true"):await d(K(s,(async(n,s)=>{o(n)?await a(I+_(t)+C+_(e)+"=$1",[s]):A(v)||await r(a,t,e,z(n),{[s]:c?g(V(n),c):V(n)},N)})));else if(A(v))F(w,t)&&await a(I+_(t)+C+" true");else{const n=m(j(na(w,t)),(a=>a!=e)),i={},o=[];Q(s??{},((a,t)=>{i[t]=g(n,(t=>c?c(a?.[t]):a?.[t])),h(o,t)})),await r(a,t,e,n,i),await a(I+_(t)+C+_(e)+`NOT IN(${P(o)})`,o)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},va=async(a,t,e,s,i)=>{const r=[1];await a("INSERT INTO"+_(t)+"("+((...a)=>E(g(a,_),n))(e,...s)+")VALUES"+E(K(i,(a=>"($"+r[0]+++","+P(a,r)+")")),n)+"ON CONFLICT("+_(e)+")DO UPDATE SET"+E(g(s,(a=>_(a)+"=excluded."+_(a))),n),K(i,((a,t)=>[t,...g(a,(a=>a??null))])).flat())},Ea=(a,t,e,n,s,i,r,[o,c,l],w,y,u,d,p,v)=>{const[E,g,A,m]=pa(t,w,y,s,p,v),h=da(a,(async()=>await m((async()=>{return await E(),a=(await g(o,c))[$]?.[l]??"null",ta(a,((a,t)=>"ï¿¼"===t?void 0:t));var a}))),(async a=>await m((async()=>{var t;await E(),await A(o,c,{[$]:{[l]:(t=a()??null,aa(t,((a,t)=>void 0===t?"ï¿¼":t)))}},!0,!0)}))),e,n,s,r,{[d]:()=>u,destroy:()=>(h.stopAutoLoad().stopAutoSave(),i(),h)},0,u);return h},ga=(a,t,e,n,s,i,r,[c,l,[w,y,u]],p,v,E,g,A,h,N,f)=>{const[C,O,T,I]=pa(t,p,v,s,A,h,N,f),L=async(a,t)=>await d(sa(l,(async([e,n,s,i],r)=>{t&&!(r in a)||await T(e,n,a[r],s,i,t)}))),b=async(a,t)=>y?await T(u,S,{[$]:a},!0,!0,t):null,D=da(a,(async()=>await I((async()=>{await C();const a=await(async()=>H(m(await d(sa(c,(async([a,t],e)=>[a,await O(e,t)]))),(a=>!Z(a[1])))))(),t=await(async()=>w?(await O(u,S))[$]:{})();return Z(a)&&o(t)?void 0:[a,t]}))),(async(a,t)=>await I((async()=>{if(await C(),o(t)){const[t,e]=a();await L(t),await b(e)}else await L(t[0],!0),await b(t[1],!0)}))),e,n,s,r,{[g]:()=>E,destroy:()=>(D.stopAutoLoad().stopAutoSave(),i(),D)},0,E);return D},Aa="ColumnName",ma="store",ha="json",Na=ma+"TableName",$a=ma+"Id"+Aa,Sa=ma+Aa,fa="autoLoadIntervalSeconds",Ca="rowId"+Aa,Oa="tableId",Ta="tableName",Ia="deleteEmptyColumns",La="deleteEmptyTable",ba={mode:ha,[fa]:1},Da={load:0,save:0,[Ta]:t+"_values"},Ra=(a,t,e,n,s)=>{const i=ea();return Q(a,((a,r)=>{const c=y(V(W(t,l(a)?{[e]:a}:a)),0,X(t));o(c[0])||n(r,c[0])||(s(r,c[0]),ia(i,r,c))})),i},Ma=(a,n,s,i,o,c,w,u,d,p,v="getDb",E)=>{let g,A,m;const h=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(s,c),[N,$,O,T]=(a=>{const e=(a=>W(ba,l(a)?{[Na]:a}:a??{}))(a),n=e[fa];if(e.mode==ha){const a=e[Na]??t;return[1,n,[a,e[$a]??S,e[Sa]??ma],ca(a)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,o=y(V(W(Da,r)),0,X(Da)),c=o[2],w=ca(c),u=ca(c);return[0,n,[Ra(s,{[Oa]:null,[Ca]:S},Oa,(a=>F(u,a)),(a=>la(w,a))),Ra(i,{[Ta]:null,[Ca]:S,[Ia]:0,[La]:0},Ta,((a,t)=>F(u,t)),((a,t)=>la(w,t))),o],w]})(n);return(N?Ea:ga)(a,h,(a=>{let t;const e=()=>t=setInterval((async()=>{try{const[{d:t,s:e,c:n}]=await h(`${f} ${D} d,${R} s,TOTAL_CHANGES() c FROM ${b}${D} JOIN ${b}${R}`);t==g&&e==A&&n==m||(null!=g&&a(),g=t,A=e,m=n)}catch{}}),1e3*$),n=()=>{g=A=m=null,r(t)},s=i((t=>{T.has(t)&&(n(),a(),e())}));return e(),()=>{n(),o(s)}}),(a=>a()),w,u,d,O,j(T),(async(a,t)=>await a(`${f} t.name tn,c.name cn FROM ${M}list()t,${M}info(t.name)c ${C} t.schema='main'AND t.type IN('table','view')AND t.name IN(${P(t)})ORDER BY t.name,c.name`,t)),p,v,e,E,(a=>!0===a?1:!1===a?0:a),void 0)};exports.createCrSqliteWasmPersister=(a,t,e,n,s)=>Ma(a,e,(async(a,e=[])=>await t.execO(a,e)),(a=>t.onUpdate(((t,e,n)=>a(n)))),(a=>a()),n,s,(()=>0),1,t);
