"use strict";const t=t=>typeof t,e="",a=t(e),s="message",n=t=>null==t,r=(t,e,a)=>n(t)?a?.():e(t),o=e=>t(e)==a,i=t=>Array.isArray(t),c=t=>t.length,d=t=>{throw Error(t)},y=(t,e)=>t.forEach(e),l=(t,...e)=>t.push(...e),u=t=>t.shift(),g=Object,h=t=>g.getPrototypeOf(t),p=g.keys,v=g.freeze,w=t=>(t=>!n(t)&&r(h(t),(t=>t==g.prototype||n(h(t))),(()=>!0)))(t)&&0==(t=>c(p(t)))(t),f=JSON.stringify,S=JSON.parse,C=t=>f(t,((t,e)=>e instanceof Map?g.fromEntries([...e]):e)),A="/store",L=t=>n(t)||0==(t=>t?.size??0)(t),P=(t,e)=>t?.forEach(e),b=(t,e)=>t?.delete(e),m=t=>new Map(t),M=(t,e)=>t?.get(e),E=(t,e,a)=>n(a)?(b(t,e),t):t?.set(e,a),O=(t,e,a,s)=>{var n,r;return n=t,r=e,n?.has(r)?s?.(M(t,e)):E(t,e,a()),M(t,e)},T=(t,e,a,s,n=0)=>r((a?O:M)(t,e[n],n>c(e)-2?a:m),(r=>{if(n>c(e)-2)return s?.(r)&&E(t,e[n]),r;const o=T(r,e,a,s,n+1);return L(r)&&E(t,e[n]),o})),j=t=>new Set(i(t)||n(t)?t:[t]),k=/^\d+$/,x=m(),z=m(),D=(t,a,s,o,g,h,p,f={},S=0,C=[])=>{let A,D,J,N=0,F=0,K=0;O(x,C,(()=>0)),O(z,C,(()=>[]));const U=m(),[W,$,q,B,G]=((t=1,e,a)=>1!=t&&e.isMergeable()?[1,e.getMergeableContent,()=>e.getTransactionMergeableChanges(!a),([[t],[e]])=>!w(t)||!w(e),e.setDefaultContent]:2!=t?[0,e.getContent,e.getTransactionChanges,([t,e])=>!w(t)||!w(e),e.setContent]:d("Store type not supported by this Persister"))(p,t,S),[H,I,Q]=(()=>{let t;const[a,s]=(()=>{const t=[];let a=0;return[s=>(s?u(t):null)??e+a++,e=>{k.test(e)&&c(t)<1e3&&l(t,e)}]})(),o=m();return[(s,n,r,i=[],c=()=>[])=>{t??=et;const d=a(1);var y,l;return E(o,d,[s,n,r,i,c]),y=T(n,r??[e],j),l=d,y?.add(l),d},(a,s,...n)=>y(((t,a=[e])=>{const s=[],n=(t,e)=>e==c(a)?l(s,t):null===a[e]?P(t,(t=>n(t,e+1))):y([a[e],null],(a=>n(M(t,a),e+1)));return n(t,0),s})(a,s),(e=>P(e,(e=>M(o,e)[0](t,...s??[],...n))))),t=>r(M(o,t),(([,a,n])=>(T(a,n??[e],void 0,(e=>(b(e,t),L(e)?1:0))),E(o,t),s(t),n))),e=>r(M(o,e),(([e,,a=[],s,r])=>{const o=(...i)=>{const d=c(i);d==c(a)?e(t,...i,...r(i)):n(a[d])?y(s[d]?.(...i)??[],(t=>o(...i,t))):o(...i,a[d])};o()}))]})(),R=t=>{t!=N&&(N=t,I(U,void 0,N))},V=e=>{(W&&i(e?.[0])?1===e?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===e?.[2]?t.applyChanges:t.setContent)(e)},X=async t=>(2!=N&&(R(1),F++,await tt((async()=>{try{const e=await a();i(e)?V(e):t?G(t):d("Content is not an array: "+e)}catch(e){h?.(e),t&&G(t)}R(0)}))),et),Y=()=>(D&&(g(D),D=void 0),et),Z=async t=>(1!=N&&(R(2),K++,await tt((async()=>{try{await s($,t)}catch(t){h?.(t)}R(0)}))),et),_=()=>(J&&(t.delListener(J),J=void 0),et),tt=async(...t)=>(l(M(z,C),...t),await(async()=>{if(!M(x,C)){for(E(x,C,1);!n(A=u(M(z,C)));)try{await A()}catch(t){h?.(t)}E(x,C,0)}})(),et),et={load:X,startAutoLoad:async t=>{Y(),await X(t);try{D=await o((async(t,e)=>{e||t?2!=N&&(R(1),F++,V(e??t),R(0)):await X()}))}catch(t){h?.(t)}return et},stopAutoLoad:Y,isAutoLoading:()=>!n(D),save:Z,startAutoSave:async()=>(_(),await Z(),J=t.addDidFinishTransactionListener((()=>{const t=q();B(t)&&Z(t)})),et),stopAutoSave:_,isAutoSaving:()=>!n(J),getStatus:()=>N,addStatusListener:t=>H(t,U),delListener:e=>(Q(e),t),schedule:tt,getStore:()=>t,destroy:()=>(M(z,C).splice(0,void 0),Y().stopAutoSave()),getStats:()=>({loads:F,saves:K}),...f};return v(et)};exports.createPartyKitPersister=(t,a,n,i)=>{const{host:d,room:y}=a.partySocketOptions,{storeProtocol:l="https",storePath:u=A,messagePrefix:g=e}={...o(n)?{storeProtocol:n}:n},h=l+"://"+d+"/parties/"+a.name+"/"+y+u,p=async t=>await(await fetch(h,{...t?{method:"PUT",body:C(t)}:{},mode:"cors",cache:"no-store"})).json();return D(t,(async()=>await p()),(async(t,e)=>{var s;e?a.send(g+"s"+(o(s=e)?s:C(s))):await p(t())}),(t=>{const e=e=>r(((t,e)=>{const a=c(t);return((t,e)=>t.startsWith(e))(e,t)?[e[a],S((s=e,n=a+1,s.slice(n,void 0)))]:void 0;var s,n})(g,e.data),(([e,a])=>{"s"==e&&t(void 0,a)}));return a.addEventListener(s,e),e}),(t=>{a.removeEventListener(s,t)}),i,1,{getConnection:()=>a})};
