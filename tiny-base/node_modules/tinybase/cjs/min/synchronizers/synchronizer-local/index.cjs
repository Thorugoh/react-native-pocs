"use strict";const t=(t,e="",a)=>t.split(e,a),e=Promise,a=globalThis,n=(t,e=0)=>setTimeout(t,1e3*e),s=Math,o=s.floor,r=t=>null==t,i=(t,e,a)=>r(t)?a?.():e(t),c=t=>Array.isArray(t),l=t=>t.length,u=t=>{throw Error(t)},g=(t,e)=>t.forEach(e),y=(t,...e)=>t.push(...e),d=t=>t.shift(),h=Object,p=t=>h.getPrototypeOf(t),v=h.entries,w=h.keys,f=h.freeze,b=(t,e)=>g(v(t),(([t,a])=>e(a,t))),S=t=>(t=>!r(t)&&i(p(t),(t=>t==h.prototype||r(p(t))),(()=>!0)))(t)&&0==(t=>l(w(t)))(t),M=(t,e,a)=>(((t,e)=>e in t)(t,e)||(t[e]=a()),t[e]),A=t=>r(t)||0==(t=>t?.size??0)(t),C=(t,e)=>t?.forEach(e),L=(t,e)=>t?.delete(e),m=t=>new Map(t),T=(t,e)=>t?.get(e),H=(t,e,a)=>r(a)?(L(t,e),t):t?.set(e,a),D=(t,e,a,n)=>{var s,o;return s=t,o=e,s?.has(o)?n?.(T(t,e)):H(t,e,a()),T(t,e)},z=(t,e,a,n,s=0)=>i((a?D:T)(t,e[s],s>l(e)-2?a:m),(o=>{if(s>l(e)-2)return n?.(o)&&H(t,e[s]),o;const r=z(o,e,a,n,s+1);return A(o)&&H(t,e[s]),r})),E=(t,e)=>e?[t,e]:[t],P=(t,e)=>((t??"")>(e??"")?t:e)??"",R=(t="")=>E(((t=[])=>h.fromEntries(t))(),t),V=t=>new Set(c(t)||r(t)?t:[t]),O=/^\d+$/,$=m(),j=m(),k=(t,e,a,n,s,o,h,p={},v=0,w=[])=>{let b,M,E,P=0,R=0,k=0;D($,w,(()=>0)),D(j,w,(()=>[]));const x=m(),[F,N,U,q,B]=((t=1,e,a)=>1!=t&&e.isMergeable()?[1,e.getMergeableContent,()=>e.getTransactionMergeableChanges(!a),([[t],[e]])=>!S(t)||!S(e),e.setDefaultContent]:2!=t?[0,e.getContent,e.getTransactionChanges,([t,e])=>!S(t)||!S(e),e.setContent]:u("Store type not supported by this Persister"))(h,t,v),[G,I,J]=(()=>{let t;const[e,a]=(()=>{const t=[];let e=0;return[a=>(a?d(t):null)??""+e++,e=>{O.test(e)&&l(t)<1e3&&y(t,e)}]})(),n=m();return[(a,s,o,r=[],i=()=>[])=>{t??=tt;const c=e(1);var l,u;return H(n,c,[a,s,o,r,i]),l=z(s,o??[""],V),u=c,l?.add(u),c},(e,a,...s)=>g(((t,e=[""])=>{const a=[],n=(t,s)=>s==l(e)?y(a,t):null===e[s]?C(t,(t=>n(t,s+1))):g([e[s],null],(e=>n(T(t,e),s+1)));return n(t,0),a})(e,a),(e=>C(e,(e=>T(n,e)[0](t,...a??[],...s))))),t=>i(T(n,t),(([,e,s])=>(z(e,s??[""],void 0,(e=>(L(e,t),A(e)?1:0))),H(n,t),a(t),s))),e=>i(T(n,e),(([e,,a=[],n,s])=>{const o=(...i)=>{const c=l(i);c==l(a)?e(t,...i,...s(i)):r(a[c])?g(n[c]?.(...i)??[],(t=>o(...i,t))):o(...i,a[c])};o()}))]})(),K=t=>{t!=P&&(P=t,I(x,void 0,P))},Q=e=>{(F&&c(e?.[0])?1===e?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===e?.[2]?t.applyChanges:t.setContent)(e)},W=async t=>(2!=P&&(K(1),R++,await _((async()=>{try{const a=await e();c(a)?Q(a):t?B(t):u("Content is not an array: "+a)}catch(e){o?.(e),t&&B(t)}K(0)}))),tt),X=()=>(M&&(s(M),M=void 0),tt),Y=async t=>(1!=P&&(K(2),k++,await _((async()=>{try{await a(N,t)}catch(t){o?.(t)}K(0)}))),tt),Z=()=>(E&&(t.delListener(E),E=void 0),tt),_=async(...t)=>(y(T(j,w),...t),await(async()=>{if(!T($,w)){for(H($,w,1);!r(b=d(T(j,w)));)try{await b()}catch(t){o?.(t)}H($,w,0)}})(),tt),tt={load:W,startAutoLoad:async t=>{X(),await W(t);try{M=await n((async(t,e)=>{e||t?2!=P&&(K(1),R++,Q(e??t),K(0)):await W()}))}catch(t){o?.(t)}return tt},stopAutoLoad:X,isAutoLoading:()=>!r(M),save:Y,startAutoSave:async()=>(Z(),await Y(),E=t.addDidFinishTransactionListener((()=>{const t=U();q(t)&&Y(t)})),tt),stopAutoSave:Z,isAutoSaving:()=>!r(E),getStatus:()=>P,addStatusListener:t=>G(t,x),delListener:e=>(J(e),t),schedule:_,getStore:()=>t,destroy:()=>(T(j,w).splice(0,void 0),X().stopAutoSave()),getStats:()=>({loads:R,saves:k}),...p};return f(tt)},x=t("-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"),F=a.crypto?t=>a.crypto.getRandomValues(t):t=>(t=>t.map((()=>o(256*s.random()))))(t),N=(t=16)=>{return e=(t,e)=>t+x[63&e],F(new Uint8Array(t)).reduce(e,"");var e},U=m();exports.createLocalSynchronizer=(t,a,s,o)=>{const c=N();return((t,a,s,o,c,l,u,g,y={})=>{let d,h=0,p=0,v=0;const w=m(),f=()=>N(11),A=(t,e,n,s)=>{p++,l?.(t,e,n,s),a(t,e,n,s)},C=async(t,a,s,o)=>new e(((e,r)=>{const i=o+"."+N(4),l=n((()=>{L(w,i),r(`No response from ${t??"anyone"} to ${i}, `+a)}),c);H(w,i,[t,(t,a)=>{clearTimeout(l),L(w,i),e([t,a,o])}]),A(t,i,a,s)})),D=(t,[e,a])=>{b(e,(([e,a],n)=>{const s=M(t[0],n,R);b(e,(([t,e],a)=>{const n=M(s[0],a,R);b(t,(([t,e],a)=>n[0][a]=E(t,e))),n[1]=P(n[1],e)})),s[1]=P(s[1],a)})),t[1]=P(t[1],a)},z=async(e=null,a,n=f())=>{try{r(a)&&([a,e,n]=await C(null,1,"",n));const[s,o]=a,[i,c]=t.getMergeableContentHashes();let l=R();if(i!=s){const[a,s]=(await C(e,4,t.getMergeableTableHashes(),n))[0];if(l=a,!S(s)){const[a,o]=(await C(e,5,t.getMergeableRowHashes(s),n))[0];if(D(l,a),!S(o)){const a=(await C(e,6,t.getMergeableCellHashes(o),n))[0];D(l,a)}}}return[l,c==o?R():(await C(e,7,t.getMergeableValueHashes(),n))[0],1]}catch(t){g?.(t)}},V=k(t,(async()=>{const t=await z();return!t||S(t[0][0])&&S(t[1][0])?void 0:t}),(async(e,a)=>a?A(null,f(),3,a):A(null,f(),2,t.getMergeableContentHashes())),(t=>d=t),(()=>d=void 0),g,2,{startSync:async t=>(h=1,await(await V.startAutoLoad(t)).startAutoSave()),stopSync:()=>(h=0,V.stopAutoLoad().stopAutoSave()),destroy:()=>(o(),V.stopSync()),getSynchronizerStats:()=>({sends:p,receives:v}),...y},1);return s(((e,a,n,s)=>{const o=h||V.isAutoLoading();v++,u?.(e,a,n,s),0==n?i(T(w,a),(([t,a])=>r(t)||t==e?a(s,e):0)):2==n&&o?z(e,s,a??void 0).then((t=>{d?.(void 0,t)})).catch(g):3==n&&o?d?.(void 0,s):i(1==n&&(h||V.isAutoSaving())?t.getMergeableContentHashes():4==n?t.getMergeableTableDiff(s):5==n?t.getMergeableRowDiff(s):6==n?t.getMergeableCellDiff(s):7==n?t.getMergeableValueDiff(s):void 0,(t=>{A(e,a,0,t)}))})),V})(t,((t,e,a,s)=>n((()=>{return r(t)?(n=(t,n)=>t!=c?n(c,e,a,s):0,C(U,((t,e)=>n(e,t)))):T(U,t)?.(c,e,a,s);var n}))),(t=>{H(U,c,t)}),(()=>{L(U,c)}),.01,a,s,o)};
