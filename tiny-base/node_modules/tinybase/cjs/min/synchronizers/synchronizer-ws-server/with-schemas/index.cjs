"use strict";const t="",e="error",a=(t,e="",a)=>t.split(e,a),s=Promise,n=globalThis,o=Math,r=o.floor,i=t=>null==t,c=(t,e,a)=>i(t)?a?.():e(t),l=t=>Array.isArray(t),d=(t,e,a)=>t.slice(e,a),g=t=>t.length,u=t=>{throw Error(t)},y=(t,e)=>t.forEach(e),h=(t,e,a)=>t.reduce(e,a),v=(t,...e)=>t.push(...e),S=t=>t.shift(),w=Object,p=t=>w.getPrototypeOf(t),f=w.entries,b=w.keys,A=w.freeze,C=(t,e)=>y(f(t),(([t,a])=>e(a,t))),M=t=>(t=>!i(t)&&c(p(t),(t=>t==w.prototype||i(p(t))),(()=>!0)))(t)&&0==(t=>g(b(t)))(t),L=(t,e,a)=>(((t,e)=>e in t)(t,e)||(t[e]=a()),t[e]),m=t=>t?.size??0,T=(H=m,t=>h(k(t),((t,e)=>t+H(e)),0));var H;const D=t=>i(t)||0==m(t),k=t=>[...t?.values()??[]],O=(t,e)=>t?.forEach(e),P=(t,e)=>t?.delete(e),E=t=>new Map(t),I=t=>[...t?.keys()??[]],z=(t,e)=>t?.get(e),N=(t,e,a)=>i(a)?(P(t,e),t):t?.set(e,a),R=(t,e,a,s)=>{var n,o;return n=t,o=e,n?.has(o)?s?.(z(t,e)):N(t,e,a()),z(t,e)},V=(t,e,a,s,n=0)=>c((a?R:z)(t,e[n],n>g(e)-2?a:E),(o=>{if(n>g(e)-2)return s?.(o)&&N(t,e[n]),o;const r=V(o,e,a,s,n+1);return D(o)&&N(t,e[n]),r})),x=JSON.stringify,J=JSON.parse,W=(t,e)=>{const a=t.indexOf("\n");-1!==a&&e(d(t,0,a),d(t,a+1))},$=(t,e)=>t+"\n"+e,j=(t,e)=>e?[t,e]:[t],F=(t,e)=>((t??"")>(e??"")?t:e)??"",U=(t="")=>j(((t=[])=>w.fromEntries(t))(),t),q=t=>new Set(l(t)||i(t)?t:[t]),B=/^\d+$/,G=e=>{let a;const[s,n]=(()=>{const e=[];let a=0;return[s=>(s?S(e):null)??t+a++,t=>{B.test(t)&&g(e)<1e3&&v(e,t)}]})(),o=E();return[(n,r,i,c=[],l=()=>[])=>{a??=e();const d=s(1);var g,u;return N(o,d,[n,r,i,c,l]),g=V(r,i??[t],q),u=d,g?.add(u),d},(e,s,...n)=>y(((e,a=[t])=>{const s=[],n=(t,e)=>e==g(a)?v(s,t):null===a[e]?O(t,(t=>n(t,e+1))):y([a[e],null],(a=>n(z(t,a),e+1)));return n(e,0),s})(e,s),(t=>O(t,(t=>z(o,t)[0](a,...s??[],...n))))),e=>c(z(o,e),(([,a,s])=>(V(a,s??[t],void 0,(t=>(P(t,e),D(t)?1:0))),N(o,e),n(e),s))),t=>c(z(o,t),(([t,,e=[],s,n])=>{const o=(...r)=>{const c=g(r);c==g(e)?t(a,...r,...n(r)):i(e[c])?y(s[c]?.(...r)??[],(t=>o(...r,t))):o(...r,e[c])};o()}))]},K=E(),Q=E(),X=a("-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"),Y=n.crypto?t=>n.crypto.getRandomValues(t):t=>(t=>t.map((()=>r(256*o.random()))))(t),Z=(t=16)=>h(Y(new Uint8Array(t)),((t,e)=>t+X[63&e]),""),_=/\/([^?]*)/;exports.createWsServer=(a,n,o)=>{const r=E(),d=E(),g=E(),h=E(),[w,p,f]=G((()=>k)),b=t=>{t[1]?.destroy(),t[2]?.destroy()},H=(e,a,s)=>n=>W(n,((n,o)=>{const r=$(e,o);var i;n===t?("S"!==e&&s[3]?.(r),i=(t,a)=>t!==e?a.send(r):0,O(a,((t,e)=>i(e,t)))):"S"===n?s[3]?.(r):z(a,n)?.send(r)}));a.on("connection",((a,w)=>{return c((f=w.url,m=_,f?.match(m)),(([,f])=>c(w.headers["sec-websocket-key"],(async w=>{const m=R(g,f,E),T=R(h,f,(()=>[0])),k=H(w,m,T);D(m)&&(p(r,void 0,f,1),await(async(e,a,r)=>c(await(n?.(a)),(a=>{e[0]=1,e[1]=l(a)?a[0]:a;const n=H("S",r,e);e[2]=((e,a,n,o,r,d,g,y,h={})=>{let w,p=0,f=0,b=0;const m=E(),T=()=>Z(11),H=(t,e,s,n)=>{f++,a(t,e,s,n)},D=async(t,e,a,n)=>new s(((s,o)=>{const i=n+"."+Z(4),c=((t,e=0)=>setTimeout(t,1e3*e))((()=>{P(m,i),o(`No response from ${t??"anyone"} to ${i}, `+e)}),r);N(m,i,[t,(t,e)=>{clearTimeout(c),P(m,i),s([t,e,n])}]),H(t,i,e,a)})),k=(t,[e,a])=>{C(e,(([e,a],s)=>{const n=L(t[0],s,U);C(e,(([t,e],a)=>{const s=L(n[0],a,U);C(t,(([t,e],a)=>s[0][a]=j(t,e))),s[1]=F(s[1],e)})),n[1]=F(n[1],a)})),t[1]=F(t[1],a)},O=async(a=null,s,n=T())=>{try{i(s)&&([s,a,n]=await D(null,1,t,n));const[o,r]=s,[c,l]=e.getMergeableContentHashes();let d=U();if(c!=o){const[t,s]=(await D(a,4,e.getMergeableTableHashes(),n))[0];if(d=t,!M(s)){const[t,o]=(await D(a,5,e.getMergeableRowHashes(s),n))[0];if(k(d,t),!M(o)){const t=(await D(a,6,e.getMergeableCellHashes(o),n))[0];k(d,t)}}}return[d,l==r?U():(await D(a,7,e.getMergeableValueHashes(),n))[0],1]}catch(t){y?.(t)}},I=((t,e,a,s,n,o,r,c={},d=0,g=[])=>{let y,h,w,p=0,f=0,b=0;R(K,g,(()=>0)),R(Q,g,(()=>[]));const C=E(),[L,m,T,H,D]=((t=1,e,a)=>1!=t&&e.isMergeable()?[1,e.getMergeableContent,()=>e.getTransactionMergeableChanges(!a),([[t],[e]])=>!M(t)||!M(e),e.setDefaultContent]:2!=t?[0,e.getContent,e.getTransactionChanges,([t,e])=>!M(t)||!M(e),e.setContent]:u("Store type not supported by this Persister"))(r,t,d),[k,O,P]=G((()=>F)),I=t=>{t!=p&&(p=t,O(C,void 0,p))},V=e=>{(L&&l(e?.[0])?1===e?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===e?.[2]?t.applyChanges:t.setContent)(e)},x=async t=>(2!=p&&(I(1),f++,await j((async()=>{try{const a=await e();l(a)?V(a):t?D(t):u("Content is not an array: "+a)}catch(e){o?.(e),t&&D(t)}I(0)}))),F),J=()=>(h&&(n(h),h=void 0),F),W=async t=>(1!=p&&(I(2),b++,await j((async()=>{try{await a(m,t)}catch(t){o?.(t)}I(0)}))),F),$=()=>(w&&(t.delListener(w),w=void 0),F),j=async(...t)=>(v(z(Q,g),...t),await(async()=>{if(!z(K,g)){for(N(K,g,1);!i(y=S(z(Q,g)));)try{await y()}catch(t){o?.(t)}N(K,g,0)}})(),F),F={load:x,startAutoLoad:async t=>{J(),await x(t);try{h=await s((async(t,e)=>{e||t?2!=p&&(I(1),f++,V(e??t),I(0)):await x()}))}catch(t){o?.(t)}return F},stopAutoLoad:J,isAutoLoading:()=>!i(h),save:W,startAutoSave:async()=>($(),await W(),w=t.addDidFinishTransactionListener((()=>{const t=T();H(t)&&W(t)})),F),stopAutoSave:$,isAutoSaving:()=>!i(w),getStatus:()=>p,addStatusListener:t=>k(t,C),delListener:e=>(P(e),t),schedule:j,getStore:()=>t,destroy:()=>(z(Q,g).splice(0,void 0),J().stopAutoSave()),getStats:()=>({loads:f,saves:b}),...c};return A(F)})(e,(async()=>{const t=await O();return!t||M(t[0][0])&&M(t[1][0])?void 0:t}),(async(t,a)=>a?H(null,T(),3,a):H(null,T(),2,e.getMergeableContentHashes())),(t=>w=t),(()=>w=void 0),y,2,{startSync:async t=>(p=1,await(await I.startAutoLoad(t)).startAutoSave()),stopSync:()=>(p=0,I.stopAutoLoad().stopAutoSave()),destroy:()=>I.stopSync(),getSynchronizerStats:()=>({sends:f,receives:b}),...h},1);return n(((t,a,s,n)=>{const o=p||I.isAutoLoading();b++,0==s?c(z(m,a),(([e,a])=>i(e)||e==t?a(n,t):0)):2==s&&o?O(t,n,a??void 0).then((t=>{w?.(void 0,t)})).catch(y):3==s&&o?w?.(void 0,n):c(1==s&&(p||I.isAutoSaving())?e.getMergeableContentHashes():4==s?e.getMergeableTableDiff(n):5==s?e.getMergeableRowDiff(n):6==s?e.getMergeableCellDiff(n):7==s?e.getMergeableValueDiff(n):void 0,(e=>{H(t,a,0,e)}))})),I})(e[1].getStore(),((e,a,s,o)=>n(((e,...a)=>$(e??t,x(a,((t,e)=>void 0===e?"￼":e))))(e,a,s,o))),(t=>e[3]=e=>((t,e)=>W(t,((t,a)=>{return e(t,...(s=a,J(s,((t,e)=>"￼"===e?void 0:e))));var s})))(e,t)),0,1,0,0,o),e[4]=[],e[5]=l(a)?a[1]:t=>0})))(T,f,m)),N(m,w,a),p(d,[f],w,1),a.on("message",(t=>{const e=t.toString("utf8");0==T[0]?k(e):v(T[4],e)})),1==T[0]&&(await(async t=>{t[0]=2,await t[1].schedule(t[1].startAutoLoad,t[1].startAutoSave,t[2].startSync),t[5](t[1].getStore()),t[0]=0})(T),y(T[4],k),T[4]=[]),a.on("close",(()=>{P(m,w),p(d,[f],w,-1),D(m)&&(b(T),P(h,f),P(g,f),p(r,void 0,f,-1))})),o&&a.on(e,o)}))));var f,m})),o&&a.on(e,o);const k={getWebSocketServer:()=>a,getPathIds:()=>I(g),getClientIds:t=>I(z(g,t)),addPathIdsListener:t=>w(t,r),addClientIdsListener:(t,e)=>w(e,d,[t]),delListener:t=>(f(t),k),getStats:()=>({paths:m(g),clients:T(g)}),destroy:()=>{g.clear(),O(h,b),a.close()}};return A(k)};
