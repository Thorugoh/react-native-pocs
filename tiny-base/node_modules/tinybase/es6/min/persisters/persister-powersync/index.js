const e=e=>typeof e,n="tinybase",l="",t=",",o=e(l),r=Promise,i=clearInterval,u=e=>null==e,a=(e,n,l)=>u(e)?null==l?void 0:l():n(e),d=n=>e(n)==o,c=e=>Array.isArray(e),s=(e,n,l)=>e.slice(n,l),v=e=>e.length,y=e=>{return n=function*(){return r.all(e)},new Promise(((e,l)=>{var t=e=>{try{r(n.next(e))}catch(e){l(e)}},o=e=>{try{r(n.throw(e))}catch(e){l(e)}},r=n=>n.done?e(n.value):Promise.resolve(n.value).then(t,o);r((n=n.apply(void 0,null)).next())}));var n},f=e=>{throw Error(e)},h=(e,n)=>e.forEach(n),p=(e,n="")=>e.join(n),m=(e,n)=>e.map(n),E=e=>0==v(e),g=(e,n)=>e.filter(n),b=(e,...n)=>e.push(...n),w=e=>e.shift(),P=Object,A=e=>P.getPrototypeOf(e),O=P.entries,S=P.keys,N=P.freeze,T=(e=[])=>P.fromEntries(e),C=(...e)=>P.assign({},...e),$=(e,n)=>(delete e[n],e),I=(e,n)=>m(O(e),(([e,l])=>n(l,e))),x=(e,n)=>T(I(e,((e,l)=>[l,n(e,l)]))),L=e=>P.values(e),R=e=>v(S(e)),D=e=>(e=>!u(e)&&a(A(e),(e=>e==P.prototype||u(A(e))),(()=>!0)))(e)&&0==R(e),M=e=>new Set(c(e)||u(e)?e:[e]),_=(e,n)=>null==e?void 0:e.add(n),j="_",F="_id",U="SELECT",B="WHERE",H="TABLE",J="ALTER "+H,Y="DELETE FROM",k=U+"*FROM",z="pragma_",G="data_version",V="schema_version",W="pragma_table_",K=e=>`"${e.replace(/"/g,'""')}"`,Q=(...e)=>p(m(e,K),t),X=(e,n=[1])=>p(m(e,(()=>"$"+n[0]++)),t),q=(e,n)=>{var l;return null!=(l=null==e?void 0:e.has(n))&&l},Z=e=>u(e)||0==(e=>{var n;return null!=(n=null==e?void 0:e.size)?n:0})(e),ee=e=>{var n;return[...null!=(n=null==e?void 0:e.values())?n:[]]},ne=(e,n)=>null==e?void 0:e.forEach(n),le=(e,n)=>null==e?void 0:e.delete(n),te=JSON.stringify,oe=JSON.parse,re=e=>new Map(e),ie=(e,n)=>null==e?void 0:e.get(n),ue=(e,n)=>{var l;return m([...null!=(l=null==e?void 0:e.entries())?l:[]],(([e,l])=>n(l,e)))},ae=(e,n,l)=>u(l)?(le(e,n),e):null==e?void 0:e.set(n,l),de=(e,n,l,t)=>(q(e,n)?null==t||t(ie(e,n)):ae(e,n,l()),ie(e,n)),ce=(e,n,l,t,o=0)=>a((l?de:ie)(e,n[o],o>v(n)-2?l:re),(r=>{if(o>v(n)-2)return(null==t?void 0:t(r))&&ae(e,n[o]),r;const i=ce(r,n,l,t,o+1);return Z(r)&&ae(e,n[o]),i})),se=/^\d+$/;var ve=Object.defineProperty,ye=Object.getOwnPropertySymbols,fe=Object.prototype.hasOwnProperty,he=Object.prototype.propertyIsEnumerable,pe=(e,n,l)=>n in e?ve(e,n,{enumerable:!0,configurable:!0,writable:!0,value:l}):e[n]=l,me=(e,n,l)=>new Promise(((t,o)=>{var r=e=>{try{u(l.next(e))}catch(e){o(e)}},i=e=>{try{u(l.throw(e))}catch(e){o(e)}},u=e=>e.done?t(e.value):Promise.resolve(e.value).then(r,i);u((l=l.apply(e,n)).next())}));const Ee=re(),ge=re(),be=(e,n,t,o,r,i,d,s={},y=0,p=[])=>{let m,E,g,P=0,A=0,O=0;de(Ee,p,(()=>0)),de(ge,p,(()=>[]));const S=re(),[T,C,$,I,x]=((e=1,n,l)=>1!=e&&n.isMergeable()?[1,n.getMergeableContent,()=>n.getTransactionMergeableChanges(!l),([[e],[n]])=>!D(e)||!D(n),n.setDefaultContent]:2!=e?[0,n.getContent,n.getTransactionChanges,([e,n])=>!D(e)||!D(n),n.setContent]:f("Store type not supported by this Persister"))(d,e,y),[L,R,j]=(()=>{let e;const[n,t]=(()=>{const e=[];let n=0;return[t=>{var o;return null!=(o=t?w(e):null)?o:l+n++},n=>{se.test(n)&&v(e)<1e3&&b(e,n)}]})(),o=re();return[(t,r,i,u=[],a=()=>[])=>{null!=e||(e=z);const d=n(1);return ae(o,d,[t,r,i,u,a]),_(ce(r,null!=i?i:[l],M),d),d},(n,t,...r)=>h(((e,n=[l])=>{const t=[],o=(e,l)=>l==v(n)?b(t,e):null===n[l]?ne(e,(e=>o(e,l+1))):h([n[l],null],(n=>o(ie(e,n),l+1)));return o(e,0),t})(n,t),(n=>ne(n,(n=>ie(o,n)[0](e,...null!=t?t:[],...r))))),e=>a(ie(o,e),(([,n,r])=>(ce(n,null!=r?r:[l],void 0,(n=>(le(n,e),Z(n)?1:0))),ae(o,e),t(e),r))),n=>a(ie(o,n),(([n,,l=[],t,o])=>{const r=(...i)=>{var a,d;const c=v(i);c==v(l)?n(e,...i,...o(i)):u(l[c])?h(null!=(d=null==(a=t[c])?void 0:a.call(t,...i))?d:[],(e=>r(...i,e))):r(...i,l[c])};r()}))]})(),F=e=>{e!=P&&(P=e,R(S,void 0,P))},U=n=>{(T&&c(null==n?void 0:n[0])?1===(null==n?void 0:n[2])?e.applyMergeableChanges:e.setMergeableContent:1===(null==n?void 0:n[2])?e.applyChanges:e.setContent)(n)},B=e=>me(void 0,null,(function*(){return 2!=P&&(F(1),A++,yield k((()=>me(void 0,null,(function*(){try{const l=yield n();c(l)?U(l):e?x(e):f("Content is not an array: "+l)}catch(n){null==i||i(n),e&&x(e)}F(0)}))))),z})),H=()=>(E&&(r(E),E=void 0),z),J=e=>me(void 0,null,(function*(){return 1!=P&&(F(2),O++,yield k((()=>me(void 0,null,(function*(){try{yield t(C,e)}catch(e){null==i||i(e)}F(0)}))))),z})),Y=()=>(g&&(e.delListener(g),g=void 0),z),k=(...e)=>me(void 0,null,(function*(){return b(ie(ge,p),...e),yield me(void 0,null,(function*(){if(!ie(Ee,p)){for(ae(Ee,p,1);!u(m=w(ie(ge,p)));)try{yield m()}catch(e){null==i||i(e)}ae(Ee,p,0)}})),z})),z=((e,n)=>{for(var l in n||(n={}))fe.call(n,l)&&pe(e,l,n[l]);if(ye)for(var l of ye(n))he.call(n,l)&&pe(e,l,n[l]);return e})({load:B,startAutoLoad:e=>me(void 0,null,(function*(){H(),yield B(e);try{E=yield o(((e,n)=>me(void 0,null,(function*(){n||e?2!=P&&(F(1),A++,U(null!=n?n:e),F(0)):yield B()}))))}catch(e){null==i||i(e)}return z})),stopAutoLoad:H,isAutoLoading:()=>!u(E),save:J,startAutoSave:()=>me(void 0,null,(function*(){return Y(),yield J(),g=e.addDidFinishTransactionListener((()=>{const e=$();I(e)&&J(e)})),z})),stopAutoSave:Y,isAutoSaving:()=>!u(g),getStatus:()=>P,addStatusListener:e=>L(e,S),delListener:n=>(j(n),e),schedule:k,getStore:()=>e,destroy:()=>(ie(ge,p).splice(0,void 0),H().stopAutoSave()),getStats:()=>({loads:A,saves:O})},s);return N(z)};var we=(e,n,l)=>new Promise(((t,o)=>{var r=e=>{try{u(l.next(e))}catch(e){o(e)}},i=e=>{try{u(l.throw(e))}catch(e){o(e)}},u=e=>e.done?t(e.value):Promise.resolve(e.value).then(r,i);u((l=l.apply(e,n)).next())}));const Pe=(e,n,l,o,r,i=Ae,a,d)=>{const c=re();return[()=>we(void 0,null,(function*(){c.clear(),m(yield l(e,n),(({tn:e,cn:n})=>_(de(c,e,M),n)))})),(n,l)=>we(void 0,null,(function*(){return((e,n)=>q(ie(c,e),n))(n,l)?T(g(m(yield e(k+K(n)),(e=>[e[l],d?x($(e,l),d):$(e,l)])),(([e,n])=>!u(e)&&!D(n)))):{}})),(n,l,o,d,s,v=!1)=>we(void 0,null,(function*(){const f=M();x(null!=o?o:{},(e=>m(S(null!=e?e:{}),(e=>_(f,e)))));const h=ee(f);if(!v&&s&&E(h)&&q(c,n))return yield e("DROP "+H+K(n)),void ae(c,n);const w=ie(c,n),P=M(ee(w));if(E(h)||(q(c,n)?yield y(m([l,...h],((t,o)=>we(void 0,null,(function*(){le(P,t)||(yield e(J+K(n)+"ADD"+K(t)+r),0==o&&(yield e("CREATE UNIQUE INDEX pk ON "+K(n)+`(${K(l)})`)),_(w,t))}))))):(yield e("CREATE "+H+K(n)+`(${K(l)}${r} PRIMARY KEY${p(m(h,(e=>t+K(e)+r)))});`),ae(c,n,M([l,...h])))),yield y([...!v&&d?m(ee(P),(t=>we(void 0,null,(function*(){t!=l&&(yield e(J+K(n)+"DROP"+K(t)),le(w,t))})))):[]]),v)u(o)?yield e(Y+K(n)+B+" true"):yield y(I(o,((t,o)=>we(void 0,null,(function*(){u(t)?yield e(Y+K(n)+B+K(l)+"=$1",[o]):E(h)||(yield i(e,n,l,S(t),{[o]:a?m(L(t),a):L(t)},w))})))));else if(E(h))q(c,n)&&(yield e(Y+K(n)+B+" true"));else{const t=g(ee(ie(c,n)),(e=>e!=l)),r={},u=[];x(null!=o?o:{},((e,n)=>{r[n]=m(t,(n=>a?a(null==e?void 0:e[n]):null==e?void 0:e[n])),b(u,n)})),yield i(e,n,l,t,r),yield e(Y+K(n)+B+K(l)+`NOT IN(${X(u)})`,u)}})),n=>we(void 0,null,(function*(){let l;yield e("BEGIN");try{l=yield n()}catch(e){null==o||o(e)}return yield e("END"),l}))]},Ae=(e,n,l,o,r)=>we(void 0,null,(function*(){const i=[1];yield e("INSERT INTO"+K(n)+"("+Q(l,...o)+")VALUES"+p(I(r,(e=>"($"+i[0]+++","+X(e,i)+")")),t)+"ON CONFLICT("+K(l)+")DO UPDATE SET"+p(m(o,(e=>K(e)+"=excluded."+K(e))),t),I(r,((e,n)=>[n,...m(e,(e=>null!=e?e:null))])).flat())}));var Oe=(e,n,l)=>new Promise(((t,o)=>{var r=e=>{try{u(l.next(e))}catch(e){o(e)}},i=e=>{try{u(l.throw(e))}catch(e){o(e)}},u=e=>e.done?t(e.value):Promise.resolve(e.value).then(r,i);u((l=l.apply(e,n)).next())}));const Se=(e,n,l,t,o,r,i,[u,a,d],c,s,v,y,f,h)=>{const[p,m,E,g]=Pe(n,c,s,o,f,h),b=be(e,(()=>Oe(void 0,null,(function*(){return yield g((()=>Oe(void 0,null,(function*(){var e,n,l;return yield p(),l=null!=(n=null==(e=(yield m(u,a))[j])?void 0:e[d])?n:"null",oe(l,((e,n)=>"￼"===n?void 0:n))}))))}))),(e=>Oe(void 0,null,(function*(){return yield g((()=>Oe(void 0,null,(function*(){var n,l;yield p(),yield E(u,a,{[j]:{[d]:(l=null!=(n=e())?n:null,te(l,((e,n)=>void 0===n?"￼":n)))}},!0,!0)}))))}))),l,t,o,i,{[y]:()=>v,destroy:()=>(b.stopAutoLoad().stopAutoSave(),r(),b)},0,v);return b};var Ne=(e,n,l)=>new Promise(((t,o)=>{var r=e=>{try{u(l.next(e))}catch(e){o(e)}},i=e=>{try{u(l.throw(e))}catch(e){o(e)}},u=e=>e.done?t(e.value):Promise.resolve(e.value).then(r,i);u((l=l.apply(e,n)).next())}));const Te=(e,n,l,t,o,r,i,[a,d,[c,s,v]],f,h,p,m,E,b,w,P)=>{const[A,O,S,N]=Pe(n,f,h,o,E,b,w,P),C=(e,n)=>Ne(void 0,null,(function*(){return yield y(ue(d,((l,t)=>Ne(void 0,[l,t],(function*([l,t,o,r],i){n&&!(i in e)||(yield S(l,t,e[i],o,r,n))})))))})),$=(e,n)=>Ne(void 0,null,(function*(){return s?yield S(v,F,{[j]:e},!0,!0,n):null})),I=be(e,(()=>Ne(void 0,null,(function*(){return yield N((()=>Ne(void 0,null,(function*(){yield A();const e=yield Ne(void 0,null,(function*(){return T(g(yield y(ue(a,((e,n)=>Ne(void 0,[e,n],(function*([e,n],l){return[e,yield O(l,n)]}))))),(e=>!D(e[1]))))})),n=yield Ne(void 0,null,(function*(){return c?(yield O(v,F))[j]:{}}));return D(e)&&u(n)?void 0:[e,n]}))))}))),((e,n)=>Ne(void 0,null,(function*(){return yield N((()=>Ne(void 0,null,(function*(){if(yield A(),u(n)){const[n,l]=e();yield C(n),yield $(l)}else yield C(n[0],!0),yield $(n[1],!0)}))))}))),l,t,o,i,{[m]:()=>p,destroy:()=>(I.stopAutoLoad().stopAutoSave(),r(),I)},0,p);return I},Ce="ColumnName",$e="store",Ie="json",xe=$e+"TableName",Le=$e+"Id"+Ce,Re=$e+Ce,De="autoLoadIntervalSeconds",Me="rowId"+Ce,_e="tableId",je="tableName",Fe="deleteEmptyColumns",Ue="deleteEmptyTable",Be={mode:Ie,[De]:1},He={load:0,save:0,[je]:n+"_values"},Je=(e,n,l,t,o)=>{const r=re();return x(e,((e,i)=>{const a=s(L(C(n,d(e)?{[l]:e}:e)),0,R(n));u(a[0])||t(i,a[0])||(o(i,a[0]),ae(r,i,a))})),r};var Ye=(e,n,l)=>new Promise(((t,o)=>{var r=e=>{try{u(l.next(e))}catch(e){o(e)}},i=e=>{try{u(l.throw(e))}catch(e){o(e)}},u=e=>e.done?t(e.value):Promise.resolve(e.value).then(r,i);u((l=l.apply(e,n)).next())}));const ke=(e,t,o,r,u,a,c,v,y,f,h="getDb",p)=>{let m,E,g;const b=((e,n)=>n?(l,t)=>{return o=function*(){return n(l,t),yield e(l,t)},new Promise(((e,n)=>{var l=e=>{try{r(o.next(e))}catch(e){n(e)}},t=e=>{try{r(o.throw(e))}catch(e){n(e)}},r=n=>n.done?e(n.value):Promise.resolve(n.value).then(l,t);r((o=o.apply(void 0,null)).next())}));var o}:e)(o,a),[w,P,A,O]=(e=>{var l,t,o;const r=(e=>C(Be,d(e)?{[xe]:e}:null!=e?e:{}))(e),i=r[De];if(r.mode==Ie){const e=null!=(l=r[xe])?l:n;return[1,i,[e,null!=(t=r[Le])?t:F,null!=(o=r[Re])?o:$e],M(e)]}const{tables:{load:u={},save:a={}}={},values:c={}}=r,v=s(L(C(He,c)),0,R(He)),y=v[2],f=M(y),h=M(y);return[0,i,[Je(u,{[_e]:null,[Me]:F},_e,(e=>q(h,e)),(e=>_(f,e))),Je(a,{[je]:null,[Me]:F,[Fe]:0,[Ue]:0},je,((e,n)=>q(h,n)),((e,n)=>_(f,n))),v],f]})(t);return(w?Se:Te)(e,b,(e=>{let n;const l=()=>n=setInterval((()=>Ye(void 0,null,(function*(){try{const[{d:n,s:l,c:t}]=yield b(`${U} ${G} d,${V} s,TOTAL_CHANGES() c FROM ${z}${G} JOIN ${z}${V}`);n==m&&l==E&&t==g||(null!=m&&e(),m=n,E=l,g=t)}catch(e){}}))),1e3*P),t=()=>{m=E=g=null,i(n)},o=r((n=>{O.has(n)&&(t(),e(),l())}));return l(),()=>{t(),u(o)}}),(e=>e()),c,v,y,A,ee(O),((e,n)=>Ye(void 0,null,(function*(){return yield e(`${U} t.name tn,c.name cn FROM ${W}list()t,${W}info(t.name)c ${B} t.schema='main'AND t.type IN('table','view')AND t.name IN(${X(n)})ORDER BY t.name,c.name`,n)}))),f,h,l,p,(e=>!0===e?1:!1===e?0:e),void 0)};var ze=(e,n)=>(n=Symbol[e])?n:Symbol.for("Symbol."+e),Ge=(e,n,l)=>new Promise(((t,o)=>{var r=e=>{try{u(l.next(e))}catch(e){o(e)}},i=e=>{try{u(l.throw(e))}catch(e){o(e)}},u=e=>e.done?t(e.value):Promise.resolve(e.value).then(r,i);u((l=l.apply(e,n)).next())}));const Ve=(e,n,l,t,o)=>{let r;return ke(e,l,((e,...l)=>Ge(void 0,[e,...l],(function*(e,l=[]){return n.execute(e,l).then((e=>{var n,l;return null!=(l=null==(n=e.rows)?void 0:n._array)?l:[]}))}))),(e=>{const l=new AbortController,t=n.onChange({rawTableNames:!0,signal:l.signal});return Ge(void 0,null,(function*(){try{for(var e,n,l,o=((e,n,l)=>(n=e[ze("asyncIterator")])?n.call(e):(e=e[ze("iterator")](),n={},(l=(l,t)=>(t=e[l])&&(n[l]=n=>new Promise(((l,o,r)=>(n=t.call(e,n),r=n.done,Promise.resolve(n.value).then((e=>l({value:e,done:r})),o))))))("next"),l("return"),n))(t);e=!(n=yield o.next()).done;e=!1){const e=n.value;r&&m(e.changedTables,r)}}catch(n){l=[n]}finally{try{e&&(n=o.return)&&(yield n.call(o))}finally{if(l)throw l[0]}}})),r=e,l}),(e=>{r=void 0,e.abort()}),t,o,(()=>0),1,n,"getPowerSync",We)},We=(e,n,l,o,r,i)=>Ge(void 0,null,(function*(){const u=[1],a=M(o),d=i?g([...i],(e=>e!=l&&!q(a,e))):[];if(!E(d)){const t=S(r),o=T(m(yield e("SELECT"+Q(l,...d)+"FROM"+K(n)+"WHERE"+K(l)+"IN("+X(t)+")",t),(e=>[e[l],e])));h(t,(e=>b(r[e],...m(d,(n=>{var l,t;return null!=(t=null==(l=null==o?void 0:o[e])?void 0:l[n])?t:null})))))}yield e("INSERT OR REPLACE INTO"+K(n)+"("+Q(l,...o,...d)+")VALUES"+p(I(r,(e=>"($"+u[0]+++","+X(e,u)+")")),t),I(r,((e,n)=>[n,...m(e,(e=>null!=e?e:null))])).flat())}));export{Ve as createPowerSyncPersister};
