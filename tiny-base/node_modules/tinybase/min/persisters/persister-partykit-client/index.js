const t=t=>typeof t,e="",a=t(e),s="message",n=t=>null==t,o=(t,e,a)=>n(t)?a?.():e(t),r=e=>t(e)==a,i=t=>Array.isArray(t),c=t=>t.length,d=t=>{throw Error(t)},y=(t,e)=>t.forEach(e),l=(t,...e)=>t.push(...e),u=t=>t.shift(),g=Object,h=t=>g.getPrototypeOf(t),p=g.keys,v=g.freeze,w=t=>(t=>!n(t)&&o(h(t),(t=>t==g.prototype||n(h(t))),(()=>!0)))(t)&&0==(t=>c(p(t)))(t),f=JSON.stringify,S=JSON.parse,C=t=>f(t,((t,e)=>e instanceof Map?g.fromEntries([...e]):e)),A="/store",L=t=>n(t)||0==(t=>t?.size??0)(t),b=(t,e)=>t?.forEach(e),m=(t,e)=>t?.delete(e),M=t=>new Map(t),P=(t,e)=>t?.get(e),E=(t,e,a)=>n(a)?(m(t,e),t):t?.set(e,a),O=(t,e,a,s)=>{var n,o;return n=t,o=e,n?.has(o)?s?.(P(t,e)):E(t,e,a()),P(t,e)},T=(t,e,a,s,n=0)=>o((a?O:P)(t,e[n],n>c(e)-2?a:M),(o=>{if(n>c(e)-2)return s?.(o)&&E(t,e[n]),o;const r=T(o,e,a,s,n+1);return L(o)&&E(t,e[n]),r})),j=t=>new Set(i(t)||n(t)?t:[t]),k=/^\d+$/,x=M(),z=M(),D=(t,a,s,r,g,h,p,f={},S=0,C=[])=>{let A,D,J,N=0,F=0,U=0;O(x,C,(()=>0)),O(z,C,(()=>[]));const W=M(),[$,q,B,G,H]=((t=1,e,a)=>1!=t&&e.isMergeable()?[1,e.getMergeableContent,()=>e.getTransactionMergeableChanges(!a),([[t],[e]])=>!w(t)||!w(e),e.setDefaultContent]:2!=t?[0,e.getContent,e.getTransactionChanges,([t,e])=>!w(t)||!w(e),e.setContent]:d("Store type not supported by this Persister"))(p,t,S),[I,K,Q]=(()=>{let t;const[a,s]=(()=>{const t=[];let a=0;return[s=>(s?u(t):null)??e+a++,e=>{k.test(e)&&c(t)<1e3&&l(t,e)}]})(),r=M();return[(s,n,o,i=[],c=()=>[])=>{t??=et;const d=a(1);var y,l;return E(r,d,[s,n,o,i,c]),y=T(n,o??[e],j),l=d,y?.add(l),d},(a,s,...n)=>y(((t,a=[e])=>{const s=[],n=(t,e)=>e==c(a)?l(s,t):null===a[e]?b(t,(t=>n(t,e+1))):y([a[e],null],(a=>n(P(t,a),e+1)));return n(t,0),s})(a,s),(e=>b(e,(e=>P(r,e)[0](t,...s??[],...n))))),t=>o(P(r,t),(([,a,n])=>(T(a,n??[e],void 0,(e=>(m(e,t),L(e)?1:0))),E(r,t),s(t),n))),e=>o(P(r,e),(([e,,a=[],s,o])=>{const r=(...i)=>{const d=c(i);d==c(a)?e(t,...i,...o(i)):n(a[d])?y(s[d]?.(...i)??[],(t=>r(...i,t))):r(...i,a[d])};r()}))]})(),R=t=>{t!=N&&(N=t,K(W,void 0,N))},V=e=>{($&&i(e?.[0])?1===e?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===e?.[2]?t.applyChanges:t.setContent)(e)},X=async t=>(2!=N&&(R(1),F++,await tt((async()=>{try{const e=await a();i(e)?V(e):t?H(t):d("Content is not an array: "+e)}catch(e){h?.(e),t&&H(t)}R(0)}))),et),Y=()=>(D&&(g(D),D=void 0),et),Z=async t=>(1!=N&&(R(2),U++,await tt((async()=>{try{await s(q,t)}catch(t){h?.(t)}R(0)}))),et),_=()=>(J&&(t.delListener(J),J=void 0),et),tt=async(...t)=>(l(P(z,C),...t),await(async()=>{if(!P(x,C)){for(E(x,C,1);!n(A=u(P(z,C)));)try{await A()}catch(t){h?.(t)}E(x,C,0)}})(),et),et={load:X,startAutoLoad:async t=>{Y(),await X(t);try{D=await r((async(t,e)=>{e||t?2!=N&&(R(1),F++,V(e??t),R(0)):await X()}))}catch(t){h?.(t)}return et},stopAutoLoad:Y,isAutoLoading:()=>!n(D),save:Z,startAutoSave:async()=>(_(),await Z(),J=t.addDidFinishTransactionListener((()=>{const t=B();G(t)&&Z(t)})),et),stopAutoSave:_,isAutoSaving:()=>!n(J),getStatus:()=>N,addStatusListener:t=>I(t,W),delListener:e=>(Q(e),t),schedule:tt,getStore:()=>t,destroy:()=>(P(z,C).splice(0,void 0),Y().stopAutoSave()),getStats:()=>({loads:F,saves:U}),...f};return v(et)},J=(t,a,n,i)=>{const{host:d,room:y}=a.partySocketOptions,{storeProtocol:l="https",storePath:u=A,messagePrefix:g=e}={...r(n)?{storeProtocol:n}:n},h=l+"://"+d+"/parties/"+a.name+"/"+y+u,p=async t=>await(await fetch(h,{...t?{method:"PUT",body:C(t)}:{},mode:"cors",cache:"no-store"})).json();return D(t,(async()=>await p()),(async(t,e)=>{var s;e?a.send(g+"s"+(r(s=e)?s:C(s))):await p(t())}),(t=>{const e=e=>o(((t,e)=>{const a=c(t);return((t,e)=>t.startsWith(e))(e,t)?[e[a],S((s=e,n=a+1,s.slice(n,void 0)))]:void 0;var s,n})(g,e.data),(([e,a])=>{"s"==e&&t(void 0,a)}));return a.addEventListener(s,e),e}),(t=>{a.removeEventListener(s,t)}),i,1,{getConnection:()=>a})};export{J as createPartyKitPersister};
