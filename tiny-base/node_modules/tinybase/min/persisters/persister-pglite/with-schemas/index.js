const a=a=>typeof a,t="tinybase",e=",",n=a(""),s=Promise,i=a=>null==a,o=(a,t,e)=>i(a)?e?.():t(a),r=t=>a(t)==n,c=a=>Array.isArray(a),E=(a,t,e)=>a.slice(t,e),l=a=>a.length,w=async a=>s.all(a),y=a=>{throw Error(a)},d=(a,t)=>a.forEach(t),u=(a,t="")=>a.join(t),T=(a,t)=>a.map(t),R=a=>0==l(a),A=(a,t)=>a.filter(t),N=(a,...t)=>a.push(...t),g=a=>a.shift(),p="_",C="_id",O="SELECT",L="WHERE",$="TABLE",v="ALTER "+$,I="DELETE FROM",S=O+"*FROM",m=a=>`"${a.replace(/"/g,'""')}"`,_=(a,t=[1])=>u(T(a,(()=>"$"+t[0]++)),e),h=(a,t)=>a?.has(t)??!1,f=a=>i(a)||0==(a=>a?.size??0)(a),b=a=>[...a?.values()??[]],D=(a,t)=>a?.forEach(t),P=(a,t)=>a?.delete(t),U=Object,F=a=>U.getPrototypeOf(a),M=U.entries,G=U.keys,B=U.freeze,j=(a=[])=>U.fromEntries(a),x=(...a)=>U.assign({},...a),X=(a,t)=>(delete a[t],a),Y=(a,t)=>T(M(a),(([a,e])=>t(e,a))),q=(a,t)=>j(Y(a,((a,e)=>[e,t(a,e)]))),H=a=>U.values(a),W=a=>l(G(a)),k=a=>(a=>!i(a)&&o(F(a),(a=>a==U.prototype||i(F(a))),(()=>!0)))(a)&&0==W(a),z=JSON.stringify,J=JSON.parse,K=a=>new Map(a),V=(a,t)=>a?.get(t),Q=(a,t)=>T([...a?.entries()??[]],(([a,e])=>t(e,a))),Z=(a,t,e)=>i(e)?(P(a,t),a):a?.set(t,e),aa=(a,t,e,n)=>(h(a,t)?n?.(V(a,t)):Z(a,t,e()),V(a,t)),ta=(a,t,e,n,s=0)=>o((e?aa:V)(a,t[s],s>l(t)-2?e:K),(i=>{if(s>l(t)-2)return n?.(i)&&Z(a,t[s]),i;const o=ta(i,t,e,n,s+1);return f(i)&&Z(a,t[s]),o})),ea=a=>new Set(c(a)||i(a)?a:[a]),na=(a,t)=>a?.add(t),sa=/^\d+$/,ia=K(),oa=K(),ra=(a,t,e,n,s,r,E,w={},u=0,T=[])=>{let R,A,p,C=0,O=0,L=0;aa(ia,T,(()=>0)),aa(oa,T,(()=>[]));const $=K(),[v,I,S,m,_]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!k(a)||!k(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!k(a)||!k(t),t.setContent]:y("Store type not supported by this Persister"))(E,a,u),[h,b,U]=(()=>{let a;const[t,e]=(()=>{const a=[];let t=0;return[e=>(e?g(a):null)??""+t++,t=>{sa.test(t)&&l(a)<1e3&&N(a,t)}]})(),n=K();return[(e,s,i,o=[],r=()=>[])=>{a??=q;const c=t(1);return Z(n,c,[e,s,i,o,r]),na(ta(s,i??[""],ea),c),c},(t,e,...s)=>d(((a,t=[""])=>{const e=[],n=(a,s)=>s==l(t)?N(e,a):null===t[s]?D(a,(a=>n(a,s+1))):d([t[s],null],(t=>n(V(a,t),s+1)));return n(a,0),e})(t,e),(t=>D(t,(t=>V(n,t)[0](a,...e??[],...s))))),a=>o(V(n,a),(([,t,s])=>(ta(t,s??[""],void 0,(t=>(P(t,a),f(t)?1:0))),Z(n,a),e(a),s))),t=>o(V(n,t),(([t,,e=[],n,s])=>{const o=(...r)=>{const c=l(r);c==l(e)?t(a,...r,...s(r)):i(e[c])?d(n[c]?.(...r)??[],(a=>o(...r,a))):o(...r,e[c])};o()}))]})(),F=a=>{a!=C&&(C=a,b($,void 0,C))},M=t=>{(v&&c(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},G=async a=>(2!=C&&(F(1),O++,await Y((async()=>{try{const e=await t();c(e)?M(e):a?_(a):y("Content is not an array: "+e)}catch(t){r?.(t),a&&_(a)}F(0)}))),q),j=()=>(A&&(s(A),A=void 0),q),x=async a=>(1!=C&&(F(2),L++,await Y((async()=>{try{await e(I,a)}catch(a){r?.(a)}F(0)}))),q),X=()=>(p&&(a.delListener(p),p=void 0),q),Y=async(...a)=>(N(V(oa,T),...a),await(async()=>{if(!V(ia,T)){for(Z(ia,T,1);!i(R=g(V(oa,T)));)try{await R()}catch(a){r?.(a)}Z(ia,T,0)}})(),q),q={load:G,startAutoLoad:async a=>{j(),await G(a);try{A=await n((async(a,t)=>{t||a?2!=C&&(F(1),O++,M(t??a),F(0)):await G()}))}catch(a){r?.(a)}return q},stopAutoLoad:j,isAutoLoading:()=>!i(A),save:x,startAutoSave:async()=>(X(),await x(),p=a.addDidFinishTransactionListener((()=>{const a=S();m(a)&&x(a)})),q),stopAutoSave:X,isAutoSaving:()=>!i(p),getStatus:()=>C,addStatusListener:a=>h(a,$),delListener:t=>(U(t),a),schedule:Y,getStore:()=>a,destroy:()=>(V(oa,T).splice(0,void 0),j().stopAutoSave()),getStats:()=>({loads:O,saves:L}),...w};return B(q)},ca=(a,t,n,s,o,r=Ea,c,E)=>{const l=K();return[async()=>{l.clear(),T(await n(a,t),(({tn:a,cn:t})=>na(aa(l,a,ea),t)))},async(t,e)=>((a,t)=>h(V(l,a),t))(t,e)?j(A(T(await a(S+m(t)),(a=>[a[e],E?q(X(a,e),E):X(a,e)])),(([a,t])=>!i(a)&&!k(t)))):{},async(t,n,s,E,y,d=!1)=>{const g=ea();q(s??{},(a=>T(G(a??{}),(a=>na(g,a)))));const p=b(g);if(!d&&y&&R(p)&&h(l,t))return await a("DROP "+$+m(t)),void Z(l,t);const C=V(l,t),O=ea(b(C));if(R(p)||(h(l,t)?await w(T([n,...p],(async(e,s)=>{P(O,e)||(await a(v+m(t)+"ADD"+m(e)+o),0==s&&await a("CREATE UNIQUE INDEX pk ON "+m(t)+`(${m(n)})`),na(C,e))}))):(await a("CREATE "+$+m(t)+`(${m(n)}${o} PRIMARY KEY${u(T(p,(a=>e+m(a)+o)))});`),Z(l,t,ea([n,...p])))),await w([...!d&&E?T(b(O),(async e=>{e!=n&&(await a(v+m(t)+"DROP"+m(e)),P(C,e))})):[]]),d)i(s)?await a(I+m(t)+L+" true"):await w(Y(s,(async(e,s)=>{i(e)?await a(I+m(t)+L+m(n)+"=$1",[s]):R(p)||await r(a,t,n,G(e),{[s]:c?T(H(e),c):H(e)},C)})));else if(R(p))h(l,t)&&await a(I+m(t)+L+" true");else{const e=A(b(V(l,t)),(a=>a!=n)),i={},o=[];q(s??{},((a,t)=>{i[t]=T(e,(t=>c?c(a?.[t]):a?.[t])),N(o,t)})),await r(a,t,n,e,i),await a(I+m(t)+L+m(n)+`NOT IN(${_(o)})`,o)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},Ea=async(a,t,n,s,i)=>{const o=[1];await a("INSERT INTO"+m(t)+"("+((...a)=>u(T(a,m),e))(n,...s)+")VALUES"+u(Y(i,(a=>"($"+o[0]+++","+_(a,o)+")")),e)+"ON CONFLICT("+m(n)+")DO UPDATE SET"+u(T(s,(a=>m(a)+"=excluded."+m(a))),e),Y(i,((a,t)=>[t,...T(a,(a=>a??null))])).flat())},la=(a,t,e,n,s,i,o,[r,c,E],l,w,y,d,u,T)=>{const[R,A,N,g]=ca(t,l,w,s,u,T),C=ra(a,(async()=>await g((async()=>{return await R(),a=(await A(r,c))[p]?.[E]??"null",J(a,((a,t)=>"ï¿¼"===t?void 0:t));var a}))),(async a=>await g((async()=>{var t;await R(),await N(r,c,{[p]:{[E]:(t=a()??null,z(t,((a,t)=>void 0===t?"ï¿¼":t)))}},!0,!0)}))),e,n,s,o,{[d]:()=>y,destroy:()=>(C.stopAutoLoad().stopAutoSave(),i(),C)},0,y);return C},wa=(a,t,e,n,s,o,r,[c,E,[l,y,d]],u,T,R,N,g,O,L,$)=>{const[v,I,S,m]=ca(t,u,T,s,g,O,L,$),_=async(a,t)=>await w(Q(E,(async([e,n,s,i],o)=>{t&&!(o in a)||await S(e,n,a[o],s,i,t)}))),h=async(a,t)=>y?await S(d,C,{[p]:a},!0,!0,t):null,f=ra(a,(async()=>await m((async()=>{await v();const a=await(async()=>j(A(await w(Q(c,(async([a,t],e)=>[a,await I(e,t)]))),(a=>!k(a[1])))))(),t=await(async()=>l?(await I(d,C))[p]:{})();return k(a)&&i(t)?void 0:[a,t]}))),(async(a,t)=>await m((async()=>{if(await v(),i(t)){const[t,e]=a();await _(t),await h(e)}else await _(t[0],!0),await h(t[1],!0)}))),e,n,s,r,{[N]:()=>R,destroy:()=>(f.stopAutoLoad().stopAutoSave(),o(),f)},0,R);return f},ya="ColumnName",da="store",ua="json",Ta=da+"TableName",Ra=da+"Id"+ya,Aa=da+ya,Na="autoLoadIntervalSeconds",ga="rowId"+ya,pa="tableId",Ca="tableName",Oa="deleteEmptyColumns",La="deleteEmptyTable",$a={mode:ua,[Na]:1},va={load:0,save:0,[Ca]:t+"_values"},Ia=(a,t,e,n,s)=>{const o=K();return q(a,((a,c)=>{const l=E(H(x(t,r(a)?{[e]:a}:a)),0,W(t));i(l[0])||n(c,l[0])||(s(c,l[0]),Z(o,c,l))})),o},Sa=t,ma=/^([cd]:)(.+)/,_a=t+"_data",ha=t+"_table",fa=async(a,e,n,s,i)=>((a,e,n,s,i,c,l,y,d,u,R="getDb")=>{const A=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(n,c),[N,,g,p]=(a=>{const e=(a=>x($a,r(a)?{[Ta]:a}:a??{}))(a),n=e[Na];if(e.mode==ua){const a=e[Ta]??t;return[1,n,[a,e[Ra]??C,e[Aa]??da],ea(a)]}const{tables:{load:s={},save:i={}}={},values:o={}}=e,c=E(H(x(va,o)),0,W(va)),l=c[2],w=ea(l),y=ea(l);return[0,n,[Ia(s,{[pa]:null,[ga]:C},pa,(a=>h(y,a)),(a=>na(w,a))),Ia(i,{[Ca]:null,[ga]:C,[Oa]:0,[La]:0},Ca,((a,t)=>h(y,t)),((a,t)=>na(w,t))),c],w]})(e),$=async a=>{await A(`CREATE OR REPLACE TRIGGER ${m(_a+"_"+a)} AFTER INSERT OR UPDATE OR DELETE ON ${m(a)} EXECUTE FUNCTION ${_a}()`)};return(N?la:wa)(a,A,(async a=>{await A(`CREATE OR REPLACE FUNCTION ${ha}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Sa}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await A(`CREATE EVENT TRIGGER ${ha} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${ha}();`)}catch{}return await A(`CREATE OR REPLACE FUNCTION ${_a}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Sa}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(T(b(p),(async a=>{await A(`CREATE TABLE IF NOT EXISTS ${m(a)}("_id"text PRIMARY KEY)`),await $(a)}))),await s(Sa,(async t=>{return await o((e=t,n=ma,e?.match(n)),(async([,t,e])=>{h(p,e)&&("c:"==t&&await $(e),a())}));var e,n}))}),i,l,y,d,g,b(p),(async(a,t)=>await a(`${O} table_name tn,column_name cn FROM information_schema.columns ${L} table_schema='public'AND table_name IN(${_(t)})`,t)),u,R,"text",void 0,(a=>z(a)),(a=>J(a)))})(a,n,(async(a,t=[])=>(await e.query(a,t)).rows),(async(a,t)=>await e.listen(a,t)),(async a=>{try{await a()}catch(a){i?.(a)}}),s,i,(()=>0),3,e,"getPglite");export{fa as createPglitePersister};
