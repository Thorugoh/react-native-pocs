const a=a=>typeof a,t="tinybase",e=",",n=a(""),s=Promise,i=a=>null==a,r=(a,t,e)=>i(a)?e?.():t(a),o=t=>a(t)==n,c=a=>Array.isArray(a),E=(a,t,e)=>a.slice(t,e),l=a=>a.length,w=async a=>s.all(a),y=a=>{throw Error(a)},u=(a,t)=>a.forEach(t),d=(a,t="")=>a.join(t),T=(a,t)=>a.map(t),R=a=>0==l(a),A=(a,t)=>a.filter(t),N=(a,...t)=>a.push(...t),g=a=>a.shift(),p="_",C="_id",O="SELECT",L="WHERE",v="TABLE",$="ALTER "+v,S="DELETE FROM",I=O+"*FROM",m=a=>`"${a.replace(/"/g,'""')}"`,_=(a,t=[1])=>d(T(a,(()=>"$"+t[0]++)),e),h=(a,t)=>a?.has(t)??!1,f=a=>i(a)||0==(a=>a?.size??0)(a),b=a=>[...a?.values()??[]],D=(a,t)=>a?.forEach(t),P=(a,t)=>a?.delete(t),U=Object,F=a=>U.getPrototypeOf(a),M=U.entries,G=U.keys,B=U.freeze,j=(a=[])=>U.fromEntries(a),x=(...a)=>U.assign({},...a),X=(a,t)=>(delete a[t],a),Y=(a,t)=>T(M(a),(([a,e])=>t(e,a))),q=(a,t)=>j(Y(a,((a,e)=>[e,t(a,e)]))),H=a=>U.values(a),W=a=>l(G(a)),k=a=>(a=>!i(a)&&r(F(a),(a=>a==U.prototype||i(F(a))),(()=>!0)))(a)&&0==W(a),z=JSON.stringify,J=JSON.parse,K=a=>new Map(a),V=(a,t)=>a?.get(t),Q=(a,t)=>T([...a?.entries()??[]],(([a,e])=>t(e,a))),Z=(a,t,e)=>i(e)?(P(a,t),a):a?.set(t,e),aa=(a,t,e,n)=>(h(a,t)?n?.(V(a,t)):Z(a,t,e()),V(a,t)),ta=(a,t,e,n,s=0)=>r((e?aa:V)(a,t[s],s>l(t)-2?e:K),(i=>{if(s>l(t)-2)return n?.(i)&&Z(a,t[s]),i;const r=ta(i,t,e,n,s+1);return f(i)&&Z(a,t[s]),r})),ea=a=>new Set(c(a)||i(a)?a:[a]),na=(a,t)=>a?.add(t),sa=/^\d+$/,ia=K(),ra=K(),oa=(a,t,e,n,s,o,E,w={},d=0,T=[])=>{let R,A,p,C=0,O=0,L=0;aa(ia,T,(()=>0)),aa(ra,T,(()=>[]));const v=K(),[$,S,I,m,_]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!k(a)||!k(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!k(a)||!k(t),t.setContent]:y("Store type not supported by this Persister"))(E,a,d),[h,b,U]=(()=>{let a;const[t,e]=(()=>{const a=[];let t=0;return[e=>(e?g(a):null)??""+t++,t=>{sa.test(t)&&l(a)<1e3&&N(a,t)}]})(),n=K();return[(e,s,i,r=[],o=()=>[])=>{a??=q;const c=t(1);return Z(n,c,[e,s,i,r,o]),na(ta(s,i??[""],ea),c),c},(t,e,...s)=>u(((a,t=[""])=>{const e=[],n=(a,s)=>s==l(t)?N(e,a):null===t[s]?D(a,(a=>n(a,s+1))):u([t[s],null],(t=>n(V(a,t),s+1)));return n(a,0),e})(t,e),(t=>D(t,(t=>V(n,t)[0](a,...e??[],...s))))),a=>r(V(n,a),(([,t,s])=>(ta(t,s??[""],void 0,(t=>(P(t,a),f(t)?1:0))),Z(n,a),e(a),s))),t=>r(V(n,t),(([t,,e=[],n,s])=>{const r=(...o)=>{const c=l(o);c==l(e)?t(a,...o,...s(o)):i(e[c])?u(n[c]?.(...o)??[],(a=>r(...o,a))):r(...o,e[c])};r()}))]})(),F=a=>{a!=C&&(C=a,b(v,void 0,C))},M=t=>{($&&c(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},G=async a=>(2!=C&&(F(1),O++,await Y((async()=>{try{const e=await t();c(e)?M(e):a?_(a):y("Content is not an array: "+e)}catch(t){o?.(t),a&&_(a)}F(0)}))),q),j=()=>(A&&(s(A),A=void 0),q),x=async a=>(1!=C&&(F(2),L++,await Y((async()=>{try{await e(S,a)}catch(a){o?.(a)}F(0)}))),q),X=()=>(p&&(a.delListener(p),p=void 0),q),Y=async(...a)=>(N(V(ra,T),...a),await(async()=>{if(!V(ia,T)){for(Z(ia,T,1);!i(R=g(V(ra,T)));)try{await R()}catch(a){o?.(a)}Z(ia,T,0)}})(),q),q={load:G,startAutoLoad:async a=>{j(),await G(a);try{A=await n((async(a,t)=>{t||a?2!=C&&(F(1),O++,M(t??a),F(0)):await G()}))}catch(a){o?.(a)}return q},stopAutoLoad:j,isAutoLoading:()=>!i(A),save:x,startAutoSave:async()=>(X(),await x(),p=a.addDidFinishTransactionListener((()=>{const a=I();m(a)&&x(a)})),q),stopAutoSave:X,isAutoSaving:()=>!i(p),getStatus:()=>C,addStatusListener:a=>h(a,v),delListener:t=>(U(t),a),schedule:Y,getStore:()=>a,destroy:()=>(V(ra,T).splice(0,void 0),j().stopAutoSave()),getStats:()=>({loads:O,saves:L}),...w};return B(q)},ca=(a,t,n,s,r,o=Ea,c,E)=>{const l=K();return[async()=>{l.clear(),T(await n(a,t),(({tn:a,cn:t})=>na(aa(l,a,ea),t)))},async(t,e)=>((a,t)=>h(V(l,a),t))(t,e)?j(A(T(await a(I+m(t)),(a=>[a[e],E?q(X(a,e),E):X(a,e)])),(([a,t])=>!i(a)&&!k(t)))):{},async(t,n,s,E,y,u=!1)=>{const g=ea();q(s??{},(a=>T(G(a??{}),(a=>na(g,a)))));const p=b(g);if(!u&&y&&R(p)&&h(l,t))return await a("DROP "+v+m(t)),void Z(l,t);const C=V(l,t),O=ea(b(C));if(R(p)||(h(l,t)?await w(T([n,...p],(async(e,s)=>{P(O,e)||(await a($+m(t)+"ADD"+m(e)+r),0==s&&await a("CREATE UNIQUE INDEX pk ON "+m(t)+`(${m(n)})`),na(C,e))}))):(await a("CREATE "+v+m(t)+`(${m(n)}${r} PRIMARY KEY${d(T(p,(a=>e+m(a)+r)))});`),Z(l,t,ea([n,...p])))),await w([...!u&&E?T(b(O),(async e=>{e!=n&&(await a($+m(t)+"DROP"+m(e)),P(C,e))})):[]]),u)i(s)?await a(S+m(t)+L+" true"):await w(Y(s,(async(e,s)=>{i(e)?await a(S+m(t)+L+m(n)+"=$1",[s]):R(p)||await o(a,t,n,G(e),{[s]:c?T(H(e),c):H(e)},C)})));else if(R(p))h(l,t)&&await a(S+m(t)+L+" true");else{const e=A(b(V(l,t)),(a=>a!=n)),i={},r=[];q(s??{},((a,t)=>{i[t]=T(e,(t=>c?c(a?.[t]):a?.[t])),N(r,t)})),await o(a,t,n,e,i),await a(S+m(t)+L+m(n)+`NOT IN(${_(r)})`,r)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},Ea=async(a,t,n,s,i)=>{const r=[1];await a("INSERT INTO"+m(t)+"("+((...a)=>d(T(a,m),e))(n,...s)+")VALUES"+d(Y(i,(a=>"($"+r[0]+++","+_(a,r)+")")),e)+"ON CONFLICT("+m(n)+")DO UPDATE SET"+d(T(s,(a=>m(a)+"=excluded."+m(a))),e),Y(i,((a,t)=>[t,...T(a,(a=>a??null))])).flat())},la=(a,t,e,n,s,i,r,[o,c,E],l,w,y,u,d,T)=>{const[R,A,N,g]=ca(t,l,w,s,d,T),C=oa(a,(async()=>await g((async()=>{return await R(),a=(await A(o,c))[p]?.[E]??"null",J(a,((a,t)=>"￼"===t?void 0:t));var a}))),(async a=>await g((async()=>{var t;await R(),await N(o,c,{[p]:{[E]:(t=a()??null,z(t,((a,t)=>void 0===t?"￼":t)))}},!0,!0)}))),e,n,s,r,{[u]:()=>y,destroy:()=>(C.stopAutoLoad().stopAutoSave(),i(),C)},0,y);return C},wa=(a,t,e,n,s,r,o,[c,E,[l,y,u]],d,T,R,N,g,O,L,v)=>{const[$,S,I,m]=ca(t,d,T,s,g,O,L,v),_=async(a,t)=>await w(Q(E,(async([e,n,s,i],r)=>{t&&!(r in a)||await I(e,n,a[r],s,i,t)}))),h=async(a,t)=>y?await I(u,C,{[p]:a},!0,!0,t):null,f=oa(a,(async()=>await m((async()=>{await $();const a=await(async()=>j(A(await w(Q(c,(async([a,t],e)=>[a,await S(e,t)]))),(a=>!k(a[1])))))(),t=await(async()=>l?(await S(u,C))[p]:{})();return k(a)&&i(t)?void 0:[a,t]}))),(async(a,t)=>await m((async()=>{if(await $(),i(t)){const[t,e]=a();await _(t),await h(e)}else await _(t[0],!0),await h(t[1],!0)}))),e,n,s,o,{[N]:()=>R,destroy:()=>(f.stopAutoLoad().stopAutoSave(),r(),f)},0,R);return f},ya="ColumnName",ua="store",da="json",Ta=ua+"TableName",Ra=ua+"Id"+ya,Aa=ua+ya,Na="autoLoadIntervalSeconds",ga="rowId"+ya,pa="tableId",Ca="tableName",Oa="deleteEmptyColumns",La="deleteEmptyTable",va={mode:da,[Na]:1},$a={load:0,save:0,[Ca]:t+"_values"},Sa=(a,t,e,n,s)=>{const r=K();return q(a,((a,c)=>{const l=E(H(x(t,o(a)?{[e]:a}:a)),0,W(t));i(l[0])||n(c,l[0])||(s(c,l[0]),Z(r,c,l))})),r},Ia=t,ma=/^([cd]:)(.+)/,_a=t+"_data",ha=t+"_table",fa=async(a,e,n,s,i)=>{const c=await(e.reserve?.());return((a,e,n,s,i,c,l,y,u,d,R="getDb")=>{const A=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(n,c),[N,,g,p]=(a=>{const e=(a=>x(va,o(a)?{[Ta]:a}:a??{}))(a),n=e[Na];if(e.mode==da){const a=e[Ta]??t;return[1,n,[a,e[Ra]??C,e[Aa]??ua],ea(a)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,c=E(H(x($a,r)),0,W($a)),l=c[2],w=ea(l),y=ea(l);return[0,n,[Sa(s,{[pa]:null,[ga]:C},pa,(a=>h(y,a)),(a=>na(w,a))),Sa(i,{[Ca]:null,[ga]:C,[Oa]:0,[La]:0},Ca,((a,t)=>h(y,t)),((a,t)=>na(w,t))),c],w]})(e),v=async a=>{await A(`CREATE OR REPLACE TRIGGER ${m(_a+"_"+a)} AFTER INSERT OR UPDATE OR DELETE ON ${m(a)} EXECUTE FUNCTION ${_a}()`)};return(N?la:wa)(a,A,(async a=>{await A(`CREATE OR REPLACE FUNCTION ${ha}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Ia}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await A(`CREATE EVENT TRIGGER ${ha} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${ha}();`)}catch{}return await A(`CREATE OR REPLACE FUNCTION ${_a}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Ia}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(T(b(p),(async a=>{await A(`CREATE TABLE IF NOT EXISTS ${m(a)}("_id"text PRIMARY KEY)`),await v(a)}))),await s(Ia,(async t=>{return await r((e=t,n=ma,e?.match(n)),(async([,t,e])=>{h(p,e)&&("c:"==t&&await v(e),a())}));var e,n}))}),i,l,y,u,g,b(p),(async(a,t)=>await a(`${O} table_name tn,column_name cn FROM information_schema.columns ${L} table_schema='public'AND table_name IN(${_(t)})`,t)),d,R,"text",void 0,(a=>z(a)),(a=>J(a)))})(a,n,c?.unsafe,(async(a,t)=>e.listen(a,t)),(async a=>{try{await a.unlisten()}catch(a){i?.(a)}}),s,i,(()=>c?.release?.()),3,e,"getSql")};export{fa as createPostgresPersister};
