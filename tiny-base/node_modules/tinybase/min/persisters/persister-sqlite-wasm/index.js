const a=a=>typeof a,t="tinybase",e="",n=",",s=a(e),o=Promise,i=clearInterval,r=a=>null==a,c=(a,t,e)=>r(a)?e?.():t(a),l=t=>a(t)==s,u=a=>Array.isArray(a),w=(a,t,e)=>a.slice(t,e),y=a=>a.length,d=async a=>o.all(a),p=a=>{throw Error(a)},v=(a,t)=>a.forEach(t),E=(a,t="")=>a.join(t),g=(a,t)=>a.map(t),h=a=>0==y(a),A=(a,t)=>a.filter(t),m=(a,...t)=>a.push(...t),N=a=>a.shift(),$="_",f="_id",S="SELECT",C="WHERE",O="TABLE",T="ALTER "+O,b="DELETE FROM",I=S+"*FROM",L="pragma_",R="data_version",D="schema_version",_="pragma_table_",M=a=>`"${a.replace(/"/g,'""')}"`,P=(a,t=[1])=>E(g(a,(()=>"$"+t[0]++)),n),F=(a,t)=>a?.has(t)??!1,j=a=>r(a)||0==(a=>a?.size??0)(a),k=a=>[...a?.values()??[]],U=(a,t)=>a?.forEach(t),x=(a,t)=>a?.delete(t),B=Object,J=a=>B.getPrototypeOf(a),Y=B.entries,q=B.keys,z=B.freeze,G=(a=[])=>B.fromEntries(a),H=(...a)=>B.assign({},...a),V=(a,t)=>(delete a[t],a),K=(a,t)=>g(Y(a),(([a,e])=>t(e,a))),Q=(a,t)=>G(K(a,((a,e)=>[e,t(a,e)]))),W=a=>B.values(a),X=a=>y(q(a)),Z=a=>(a=>!r(a)&&c(J(a),(a=>a==B.prototype||r(J(a))),(()=>!0)))(a)&&0==X(a),aa=JSON.stringify,ta=JSON.parse,ea=a=>new Map(a),na=(a,t)=>a?.get(t),sa=(a,t)=>g([...a?.entries()??[]],(([a,e])=>t(e,a))),oa=(a,t,e)=>r(e)?(x(a,t),a):a?.set(t,e),ia=(a,t,e,n)=>(F(a,t)?n?.(na(a,t)):oa(a,t,e()),na(a,t)),ra=(a,t,e,n,s=0)=>c((e?ia:na)(a,t[s],s>y(t)-2?e:ea),(o=>{if(s>y(t)-2)return n?.(o)&&oa(a,t[s]),o;const i=ra(o,t,e,n,s+1);return j(o)&&oa(a,t[s]),i})),ca=a=>new Set(u(a)||r(a)?a:[a]),la=(a,t)=>a?.add(t),ua=/^\d+$/,wa=ea(),ya=ea(),da=(a,t,n,s,o,i,l,w={},d=0,E=[])=>{let g,h,A,$=0,f=0,S=0;ia(wa,E,(()=>0)),ia(ya,E,(()=>[]));const C=ea(),[O,T,b,I,L]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!Z(a)||!Z(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!Z(a)||!Z(t),t.setContent]:p("Store type not supported by this Persister"))(l,a,d),[R,D,_]=(()=>{let a;const[t,n]=(()=>{const a=[];let t=0;return[n=>(n?N(a):null)??e+t++,t=>{ua.test(t)&&y(a)<1e3&&m(a,t)}]})(),s=ea();return[(n,o,i,r=[],c=()=>[])=>{a??=q;const l=t(1);return oa(s,l,[n,o,i,r,c]),la(ra(o,i??[e],ca),l),l},(t,n,...o)=>v(((a,t=[e])=>{const n=[],s=(a,e)=>e==y(t)?m(n,a):null===t[e]?U(a,(a=>s(a,e+1))):v([t[e],null],(t=>s(na(a,t),e+1)));return s(a,0),n})(t,n),(t=>U(t,(t=>na(s,t)[0](a,...n??[],...o))))),a=>c(na(s,a),(([,t,o])=>(ra(t,o??[e],void 0,(t=>(x(t,a),j(t)?1:0))),oa(s,a),n(a),o))),t=>c(na(s,t),(([t,,e=[],n,s])=>{const o=(...i)=>{const c=y(i);c==y(e)?t(a,...i,...s(i)):r(e[c])?v(n[c]?.(...i)??[],(a=>o(...i,a))):o(...i,e[c])};o()}))]})(),M=a=>{a!=$&&($=a,D(C,void 0,$))},P=t=>{(O&&u(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},F=async a=>(2!=$&&(M(1),f++,await Y((async()=>{try{const e=await t();u(e)?P(e):a?L(a):p("Content is not an array: "+e)}catch(t){i?.(t),a&&L(a)}M(0)}))),q),k=()=>(h&&(o(h),h=void 0),q),B=async a=>(1!=$&&(M(2),S++,await Y((async()=>{try{await n(T,a)}catch(a){i?.(a)}M(0)}))),q),J=()=>(A&&(a.delListener(A),A=void 0),q),Y=async(...a)=>(m(na(ya,E),...a),await(async()=>{if(!na(wa,E)){for(oa(wa,E,1);!r(g=N(na(ya,E)));)try{await g()}catch(a){i?.(a)}oa(wa,E,0)}})(),q),q={load:F,startAutoLoad:async a=>{k(),await F(a);try{h=await s((async(a,t)=>{t||a?2!=$&&(M(1),f++,P(t??a),M(0)):await F()}))}catch(a){i?.(a)}return q},stopAutoLoad:k,isAutoLoading:()=>!r(h),save:B,startAutoSave:async()=>(J(),await B(),A=a.addDidFinishTransactionListener((()=>{const a=b();I(a)&&B(a)})),q),stopAutoSave:J,isAutoSaving:()=>!r(A),getStatus:()=>$,addStatusListener:a=>R(a,C),delListener:t=>(_(t),a),schedule:Y,getStore:()=>a,destroy:()=>(na(ya,E).splice(0,void 0),k().stopAutoSave()),getStats:()=>({loads:f,saves:S}),...w};return z(q)},pa=(a,t,e,s,o,i=va,c,l)=>{const u=ea();return[async()=>{u.clear(),g(await e(a,t),(({tn:a,cn:t})=>la(ia(u,a,ca),t)))},async(t,e)=>((a,t)=>F(na(u,a),t))(t,e)?G(A(g(await a(I+M(t)),(a=>[a[e],l?Q(V(a,e),l):V(a,e)])),(([a,t])=>!r(a)&&!Z(t)))):{},async(t,e,s,l,w,y=!1)=>{const p=ca();Q(s??{},(a=>g(q(a??{}),(a=>la(p,a)))));const v=k(p);if(!y&&w&&h(v)&&F(u,t))return await a("DROP "+O+M(t)),void oa(u,t);const N=na(u,t),$=ca(k(N));if(h(v)||(F(u,t)?await d(g([e,...v],(async(n,s)=>{x($,n)||(await a(T+M(t)+"ADD"+M(n)+o),0==s&&await a("CREATE UNIQUE INDEX pk ON "+M(t)+`(${M(e)})`),la(N,n))}))):(await a("CREATE "+O+M(t)+`(${M(e)}${o} PRIMARY KEY${E(g(v,(a=>n+M(a)+o)))});`),oa(u,t,ca([e,...v])))),await d([...!y&&l?g(k($),(async n=>{n!=e&&(await a(T+M(t)+"DROP"+M(n)),x(N,n))})):[]]),y)r(s)?await a(b+M(t)+C+" true"):await d(K(s,(async(n,s)=>{r(n)?await a(b+M(t)+C+M(e)+"=$1",[s]):h(v)||await i(a,t,e,q(n),{[s]:c?g(W(n),c):W(n)},N)})));else if(h(v))F(u,t)&&await a(b+M(t)+C+" true");else{const n=A(k(na(u,t)),(a=>a!=e)),o={},r=[];Q(s??{},((a,t)=>{o[t]=g(n,(t=>c?c(a?.[t]):a?.[t])),m(r,t)})),await i(a,t,e,n,o),await a(b+M(t)+C+M(e)+`NOT IN(${P(r)})`,r)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},va=async(a,t,e,s,o)=>{const i=[1];await a("INSERT INTO"+M(t)+"("+((...a)=>E(g(a,M),n))(e,...s)+")VALUES"+E(K(o,(a=>"($"+i[0]+++","+P(a,i)+")")),n)+"ON CONFLICT("+M(e)+")DO UPDATE SET"+E(g(s,(a=>M(a)+"=excluded."+M(a))),n),K(o,((a,t)=>[t,...g(a,(a=>a??null))])).flat())},Ea=(a,t,e,n,s,o,i,[r,c,l],u,w,y,d,p,v)=>{const[E,g,h,A]=pa(t,u,w,s,p,v),m=da(a,(async()=>await A((async()=>{return await E(),a=(await g(r,c))[$]?.[l]??"null",ta(a,((a,t)=>"￼"===t?void 0:t));var a}))),(async a=>await A((async()=>{var t;await E(),await h(r,c,{[$]:{[l]:(t=a()??null,aa(t,((a,t)=>void 0===t?"￼":t)))}},!0,!0)}))),e,n,s,i,{[d]:()=>y,destroy:()=>(m.stopAutoLoad().stopAutoSave(),o(),m)},0,y);return m},ga=(a,t,e,n,s,o,i,[c,l,[u,w,y]],p,v,E,g,h,m,N,S)=>{const[C,O,T,b]=pa(t,p,v,s,h,m,N,S),I=async(a,t)=>await d(sa(l,(async([e,n,s,o],i)=>{t&&!(i in a)||await T(e,n,a[i],s,o,t)}))),L=async(a,t)=>w?await T(y,f,{[$]:a},!0,!0,t):null,R=da(a,(async()=>await b((async()=>{await C();const a=await(async()=>G(A(await d(sa(c,(async([a,t],e)=>[a,await O(e,t)]))),(a=>!Z(a[1])))))(),t=await(async()=>u?(await O(y,f))[$]:{})();return Z(a)&&r(t)?void 0:[a,t]}))),(async(a,t)=>await b((async()=>{if(await C(),r(t)){const[t,e]=a();await I(t),await L(e)}else await I(t[0],!0),await L(t[1],!0)}))),e,n,s,i,{[g]:()=>E,destroy:()=>(R.stopAutoLoad().stopAutoSave(),o(),R)},0,E);return R},ha="ColumnName",Aa="store",ma="json",Na=Aa+"TableName",$a=Aa+"Id"+ha,fa=Aa+ha,Sa="autoLoadIntervalSeconds",Ca="rowId"+ha,Oa="tableId",Ta="tableName",ba="deleteEmptyColumns",Ia="deleteEmptyTable",La={mode:ma,[Sa]:1},Ra={load:0,save:0,[Ta]:t+"_values"},Da=(a,t,e,n,s)=>{const o=ea();return Q(a,((a,i)=>{const c=w(W(H(t,l(a)?{[e]:a}:a)),0,X(t));r(c[0])||n(i,c[0])||(s(i,c[0]),oa(o,i,c))})),o},_a=(a,n,s,o,r,c,u,y,d,p,v="getDb",E)=>{let g,h,A;const m=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(s,c),[N,$,O,T]=(a=>{const e=(a=>H(La,l(a)?{[Na]:a}:a??{}))(a),n=e[Sa];if(e.mode==ma){const a=e[Na]??t;return[1,n,[a,e[$a]??f,e[fa]??Aa],ca(a)]}const{tables:{load:s={},save:o={}}={},values:i={}}=e,r=w(W(H(Ra,i)),0,X(Ra)),c=r[2],u=ca(c),y=ca(c);return[0,n,[Da(s,{[Oa]:null,[Ca]:f},Oa,(a=>F(y,a)),(a=>la(u,a))),Da(o,{[Ta]:null,[Ca]:f,[ba]:0,[Ia]:0},Ta,((a,t)=>F(y,t)),((a,t)=>la(u,t))),r],u]})(n);return(N?Ea:ga)(a,m,(a=>{let t;const e=()=>t=setInterval((async()=>{try{const[{d:t,s:e,c:n}]=await m(`${S} ${R} d,${D} s,TOTAL_CHANGES() c FROM ${L}${R} JOIN ${L}${D}`);t==g&&e==h&&n==A||(null!=g&&a(),g=t,h=e,A=n)}catch{}}),1e3*$),n=()=>{g=h=A=null,i(t)},s=o((t=>{T.has(t)&&(n(),a(),e())}));return e(),()=>{n(),r(s)}}),(a=>a()),u,y,d,O,k(T),(async(a,t)=>await a(`${S} t.name tn,c.name cn FROM ${_}list()t,${_}info(t.name)c ${C} t.schema='main'AND t.type IN('table','view')AND t.name IN(${P(t)})ORDER BY t.name,c.name`,t)),p,v,e,E,(a=>!0===a?1:!1===a?0:a),void 0)},Ma=(a,t,e,n,s,o)=>_a(a,n,(async(a,t=[])=>e.exec(a,{bind:t,rowMode:"object",returnValue:"resultRows"}).map((a=>({...a})))),(a=>t.capi.sqlite3_update_hook(e,((t,e,n,s)=>a(s)),0)),(()=>t.capi.sqlite3_update_hook(e,(()=>0),0)),s,o,(()=>0),3,e);export{Ma as createSqliteWasmPersister};
