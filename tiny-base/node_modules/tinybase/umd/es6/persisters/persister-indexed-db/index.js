(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? factory(exports)
    : typeof define === 'function' && define.amd
      ? define(['exports'], factory)
      : ((global =
          typeof globalThis !== 'undefined' ? globalThis : global || self),
        factory((global.TinyBasePersisterIndexedDb = {})));
})(this, function (exports) {
  'use strict';

  const EMPTY_STRING = '';
  const T = 't';
  const V = 'v';

  var __async$2 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) =>
        x.done
          ? resolve(x.value)
          : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const promise = Promise;
  const GLOBAL = globalThis;
  const WINDOW = GLOBAL.window;
  const THOUSAND = 1e3;
  const startInterval = (callback, sec, immediate) => {
    return setInterval(callback, sec * THOUSAND);
  };
  const stopInterval = clearInterval;
  const isUndefined = (thing) => thing == void 0;
  const ifNotUndefined = (value, then, otherwise) =>
    isUndefined(value)
      ? otherwise == null
        ? void 0
        : otherwise()
      : then(value);
  const isArray = (thing) => Array.isArray(thing);
  const size = (arrayOrString) => arrayOrString.length;
  const test = (regex, subject) => regex.test(subject);
  const promiseNew = (resolver) => new promise(resolver);
  const promiseAll = (promises) =>
    __async$2(void 0, null, function* () {
      return promise.all(promises);
    });
  const errorNew = (message) => {
    throw new Error(message);
  };

  const arrayForEach = (array, cb) => array.forEach(cb);
  const arrayMap = (array, cb) => array.map(cb);
  const arrayClear = (array, to) => array.splice(0, to);
  const arrayPush = (array, ...values) => array.push(...values);
  const arrayShift = (array) => array.shift();

  const object = Object;
  const getPrototypeOf = (obj) => object.getPrototypeOf(obj);
  const objEntries = object.entries;
  const isObject = (obj) =>
    !isUndefined(obj) &&
    ifNotUndefined(
      getPrototypeOf(obj),
      (objPrototype) =>
        objPrototype == object.prototype ||
        isUndefined(getPrototypeOf(objPrototype)),

      /* istanbul ignore next */
      () => true,
    );
  const objIds = object.keys;
  const objFreeze = object.freeze;
  const objNew = (entries = []) => object.fromEntries(entries);
  const objHas = (obj, id) => id in obj;
  const objToArray = (obj, cb) =>
    arrayMap(objEntries(obj), ([id, value]) => cb(value, id));
  const objSize = (obj) => size(objIds(obj));
  const objIsEmpty = (obj) => isObject(obj) && objSize(obj) == 0;

  const collSize = (coll) => {
    var _a;
    return (_a = coll == null ? void 0 : coll.size) != null ? _a : 0;
  };
  const collHas = (coll, keyOrValue) => {
    var _a;
    return (_a = coll == null ? void 0 : coll.has(keyOrValue)) != null
      ? _a
      : false;
  };
  const collIsEmpty = (coll) => isUndefined(coll) || collSize(coll) == 0;
  const collForEach = (coll, cb) => (coll == null ? void 0 : coll.forEach(cb));
  const collDel = (coll, keyOrValue) =>
    coll == null ? void 0 : coll.delete(keyOrValue);

  const mapNew = (entries) => new Map(entries);
  const mapGet = (map, key) => (map == null ? void 0 : map.get(key));
  const mapSet = (map, key, value) =>
    isUndefined(value)
      ? (collDel(map, key), map)
      : map == null
        ? void 0
        : map.set(key, value);
  const mapEnsure = (map, key, getDefaultValue, hadExistingValue) => {
    if (!collHas(map, key)) {
      mapSet(map, key, getDefaultValue());
    } else {
      hadExistingValue == null ? void 0 : hadExistingValue(mapGet(map, key));
    }
    return mapGet(map, key);
  };
  const visitTree = (node, path, ensureLeaf, pruneLeaf, p = 0) =>
    ifNotUndefined(
      (ensureLeaf ? mapEnsure : mapGet)(
        node,
        path[p],
        p > size(path) - 2 ? ensureLeaf : mapNew,
      ),
      (nodeOrLeaf) => {
        if (p > size(path) - 2) {
          if (pruneLeaf == null ? void 0 : pruneLeaf(nodeOrLeaf)) {
            mapSet(node, path[p]);
          }
          return nodeOrLeaf;
        }
        const leaf = visitTree(nodeOrLeaf, path, ensureLeaf, pruneLeaf, p + 1);
        if (collIsEmpty(nodeOrLeaf)) {
          mapSet(node, path[p]);
        }
        return leaf;
      },
    );

  const setNew = (entryOrEntries) =>
    new Set(
      isArray(entryOrEntries) || isUndefined(entryOrEntries)
        ? entryOrEntries
        : [entryOrEntries],
    );
  const setAdd = (set, value) => (set == null ? void 0 : set.add(value));

  const INTEGER = /^\d+$/;
  const getPoolFunctions = () => {
    const pool = [];
    let nextId = 0;
    return [
      (reuse) => {
        var _a;
        return (_a = reuse ? arrayShift(pool) : null) != null
          ? _a
          : EMPTY_STRING + nextId++;
      },
      (id) => {
        if (test(INTEGER, id) && size(pool) < 1e3) {
          arrayPush(pool, id);
        }
      },
    ];
  };

  const getWildcardedLeaves = (deepIdSet, path = [EMPTY_STRING]) => {
    const leaves = [];
    const deep = (node, p) =>
      p == size(path)
        ? arrayPush(leaves, node)
        : path[p] === null
          ? collForEach(node, (node2) => deep(node2, p + 1))
          : arrayForEach([path[p], null], (id) =>
              deep(mapGet(node, id), p + 1),
            );
    deep(deepIdSet, 0);
    return leaves;
  };
  const getListenerFunctions = (getThing) => {
    let thing;
    const [getId, releaseId] = getPoolFunctions();
    const allListeners = mapNew();
    const addListener = (
      listener,
      idSetNode,
      path,
      pathGetters = [],
      extraArgsGetter = () => [],
    ) => {
      thing != null ? thing : (thing = getThing());
      const id = getId(1);
      mapSet(allListeners, id, [
        listener,
        idSetNode,
        path,
        pathGetters,
        extraArgsGetter,
      ]);
      setAdd(
        visitTree(idSetNode, path != null ? path : [EMPTY_STRING], setNew),
        id,
      );
      return id;
    };
    const callListeners = (idSetNode, ids, ...extraArgs) =>
      arrayForEach(getWildcardedLeaves(idSetNode, ids), (set) =>
        collForEach(set, (id) =>
          mapGet(allListeners, id)[0](
            thing,
            ...(ids != null ? ids : []),
            ...extraArgs,
          ),
        ),
      );
    const delListener = (id) =>
      ifNotUndefined(mapGet(allListeners, id), ([, idSetNode, idOrNulls]) => {
        visitTree(
          idSetNode,
          idOrNulls != null ? idOrNulls : [EMPTY_STRING],
          void 0,
          (idSet) => {
            collDel(idSet, id);
            return collIsEmpty(idSet) ? 1 : 0;
          },
        );
        mapSet(allListeners, id);
        releaseId(id);
        return idOrNulls;
      });
    const callListener = (id) =>
      ifNotUndefined(
        mapGet(allListeners, id),
        ([listener, , path = [], pathGetters, extraArgsGetter]) => {
          const callWithIds = (...ids) => {
            var _a, _b;
            const index = size(ids);
            if (index == size(path)) {
              listener(thing, ...ids, ...extraArgsGetter(ids));
            } else if (isUndefined(path[index])) {
              arrayForEach(
                (_b =
                  (_a = pathGetters[index]) == null
                    ? void 0
                    : _a.call(pathGetters, ...ids)) != null
                  ? _b
                  : [],
                (id2) => callWithIds(...ids, id2),
              );
            } else {
              callWithIds(...ids, path[index]);
            }
          };
          callWithIds();
        },
      );
    return [addListener, callListeners, delListener, callListener];
  };

  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) =>
    key in obj
      ? __defProp(obj, key, {
          enumerable: true,
          configurable: true,
          writable: true,
          value,
        })
      : (obj[key] = value);
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __async$1 = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) =>
        x.done
          ? resolve(x.value)
          : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const scheduleRunning = mapNew();
  const scheduleActions = mapNew();
  const getStoreFunctions = (
    persist = 1 /* StoreOnly */,
    store,
    isSynchronizer,
  ) =>
    persist != 1 /* StoreOnly */ && store.isMergeable()
      ? [
          1,
          store.getMergeableContent,
          () => store.getTransactionMergeableChanges(!isSynchronizer),
          ([[changedTables], [changedValues]]) =>
            !objIsEmpty(changedTables) || !objIsEmpty(changedValues),
          store.setDefaultContent,
        ]
      : persist != 2 /* MergeableStoreOnly */
        ? [
            0,
            store.getContent,
            store.getTransactionChanges,
            ([changedTables, changedValues]) =>
              !objIsEmpty(changedTables) || !objIsEmpty(changedValues),
            store.setContent,
          ]
        : errorNew('Store type not supported by this Persister');
  const createCustomPersister = (
    store,
    getPersisted,
    setPersisted,
    addPersisterListener,
    delPersisterListener,
    onIgnoredError,
    persist,
    extra = {},
    isSynchronizer = 0,
    scheduleId = [],
  ) => {
    let status = 0; /* Idle */
    let loads = 0;
    let saves = 0;
    let action;
    let autoLoadHandle;
    let autoSaveListenerId;
    mapEnsure(scheduleRunning, scheduleId, () => 0);
    mapEnsure(scheduleActions, scheduleId, () => []);
    const statusListeners = mapNew();
    const [
      isMergeableStore,
      getContent,
      getChanges,
      hasChanges,
      setDefaultContent,
    ] = getStoreFunctions(persist, store, isSynchronizer);
    const [addListener, callListeners, delListenerImpl] = getListenerFunctions(
      () => persister,
    );
    const setStatus = (newStatus) => {
      if (newStatus != status) {
        status = newStatus;
        callListeners(statusListeners, void 0, status);
      }
    };
    const run = () =>
      __async$1(void 0, null, function* () {
        /* istanbul ignore else */
        if (!mapGet(scheduleRunning, scheduleId)) {
          mapSet(scheduleRunning, scheduleId, 1);
          while (
            !isUndefined(
              (action = arrayShift(mapGet(scheduleActions, scheduleId))),
            )
          ) {
            try {
              yield action();
            } catch (error) {
              /* istanbul ignore next */
              onIgnoredError == null ? void 0 : onIgnoredError(error);
            }
          }
          mapSet(scheduleRunning, scheduleId, 0);
        }
      });
    const setContentOrChanges = (contentOrChanges) => {
      (isMergeableStore &&
        isArray(contentOrChanges == null ? void 0 : contentOrChanges[0])
        ? (contentOrChanges == null ? void 0 : contentOrChanges[2]) === 1
          ? store.applyMergeableChanges
          : store.setMergeableContent
        : (contentOrChanges == null ? void 0 : contentOrChanges[2]) === 1
          ? store.applyChanges
          : store.setContent)(contentOrChanges);
    };
    const load = (initialContent) =>
      __async$1(void 0, null, function* () {
        /* istanbul ignore else */
        if (status != 2 /* Saving */) {
          setStatus(1 /* Loading */);
          loads++;
          yield schedule(() =>
            __async$1(void 0, null, function* () {
              try {
                const content = yield getPersisted();
                if (isArray(content)) {
                  setContentOrChanges(content);
                } else if (initialContent) {
                  setDefaultContent(initialContent);
                } else {
                  errorNew(`Content is not an array: ${content}`);
                }
              } catch (error) {
                onIgnoredError == null ? void 0 : onIgnoredError(error);
                if (initialContent) {
                  setDefaultContent(initialContent);
                }
              }
              setStatus(0 /* Idle */);
            }),
          );
        }
        return persister;
      });
    const startAutoLoad = (initialContent) =>
      __async$1(void 0, null, function* () {
        stopAutoLoad();
        yield load(initialContent);
        try {
          autoLoadHandle = yield addPersisterListener((content, changes) =>
            __async$1(void 0, null, function* () {
              if (changes || content) {
                /* istanbul ignore else */
                if (status != 2 /* Saving */) {
                  setStatus(1 /* Loading */);
                  loads++;
                  setContentOrChanges(changes != null ? changes : content);
                  setStatus(0 /* Idle */);
                }
              } else {
                yield load();
              }
            }),
          );
        } catch (error) {
          /* istanbul ignore next */
          onIgnoredError == null ? void 0 : onIgnoredError(error);
        }
        return persister;
      });
    const stopAutoLoad = () => {
      if (autoLoadHandle) {
        delPersisterListener(autoLoadHandle);
        autoLoadHandle = void 0;
      }
      return persister;
    };
    const isAutoLoading = () => !isUndefined(autoLoadHandle);
    const save = (changes) =>
      __async$1(void 0, null, function* () {
        /* istanbul ignore else */
        if (status != 1 /* Loading */) {
          setStatus(2 /* Saving */);
          saves++;
          yield schedule(() =>
            __async$1(void 0, null, function* () {
              try {
                yield setPersisted(getContent, changes);
              } catch (error) {
                /* istanbul ignore next */
                onIgnoredError == null ? void 0 : onIgnoredError(error);
              }
              setStatus(0 /* Idle */);
            }),
          );
        }
        return persister;
      });
    const startAutoSave = () =>
      __async$1(void 0, null, function* () {
        stopAutoSave();
        yield save();
        autoSaveListenerId = store.addDidFinishTransactionListener(() => {
          const changes = getChanges();
          if (hasChanges(changes)) {
            save(changes);
          }
        });
        return persister;
      });
    const stopAutoSave = () => {
      if (autoSaveListenerId) {
        store.delListener(autoSaveListenerId);
        autoSaveListenerId = void 0;
      }
      return persister;
    };
    const isAutoSaving = () => !isUndefined(autoSaveListenerId);
    const getStatus = () => status;
    const addStatusListener = (listener) =>
      addListener(listener, statusListeners);
    const delListener = (listenerId) => {
      delListenerImpl(listenerId);
      return store;
    };
    const schedule = (...actions) =>
      __async$1(void 0, null, function* () {
        arrayPush(mapGet(scheduleActions, scheduleId), ...actions);
        yield run();
        return persister;
      });
    const getStore = () => store;
    const destroy = () => {
      arrayClear(mapGet(scheduleActions, scheduleId));
      return stopAutoLoad().stopAutoSave();
    };
    const getStats = () => ({loads, saves});
    const persister = __spreadValues(
      {
        load,
        startAutoLoad,
        stopAutoLoad,
        isAutoLoading,
        save,
        startAutoSave,
        stopAutoSave,
        isAutoSaving,
        getStatus,
        addStatusListener,
        delListener,
        schedule,
        getStore,
        destroy,
        getStats,
      },
      extra,
    );
    return objFreeze(persister);
  };

  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) =>
        x.done
          ? resolve(x.value)
          : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  const OBJECT_STORE_NAMES = [T, V];
  const KEY_PATH = {keyPath: 'k'};
  const objectStoreMatch = (objectStore, obj) =>
    __async(void 0, null, function* () {
      const actions = objToArray(obj, (v, k) =>
        execObjectStore(objectStore, 'put', {k, v}),
      );
      arrayMap(yield execObjectStore(objectStore, 'getAllKeys'), (id) =>
        objHas(obj, id)
          ? 0
          : arrayPush(actions, execObjectStore(objectStore, 'delete', id)),
      );
      yield promiseAll(actions);
    });
  const execObjectStore = (objectStore, func, arg) =>
    __async(void 0, null, function* () {
      return promiseNew((resolve, reject) => {
        const request = objectStore[func](arg);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(`objectStore.${func} error`);
      });
    });
  const createIndexedDbPersister = (
    store,
    dbName,
    autoLoadIntervalSeconds = 1,
    onIgnoredError,
  ) => {
    const forObjectStores = (_0, ..._1) =>
      __async(
        void 0,
        [_0, ..._1],
        function* (forObjectStore, params = [], create = 0) {
          return promiseNew((resolve, reject) => {
            const request = (WINDOW ? WINDOW.indexedDB : indexedDB).open(
              dbName,
              create ? 2 : void 0,
            );
            request.onupgradeneeded = () =>
              create &&
              arrayMap(OBJECT_STORE_NAMES, (objectStoreName) => {
                try {
                  request.result.createObjectStore(objectStoreName, KEY_PATH);
                } catch (e) {}
              });
            request.onsuccess = () =>
              __async(void 0, null, function* () {
                try {
                  const transaction = request.result.transaction(
                    OBJECT_STORE_NAMES,
                    'readwrite',
                  );
                  const result = yield promiseAll(
                    arrayMap(OBJECT_STORE_NAMES, (objectStoreName, index) =>
                      __async(void 0, null, function* () {
                        return yield forObjectStore(
                          transaction.objectStore(objectStoreName),
                          params[index],
                        );
                      }),
                    ),
                  );
                  request.result.close();
                  resolve(result);
                } catch (e) {
                  request.result.close();
                  reject(e);
                }
              });
            request.onerror = () => reject('indexedDB.open error');
          });
        },
      );
    const getPersisted = () =>
      __async(void 0, null, function* () {
        return yield forObjectStores((objectStore) =>
          __async(void 0, null, function* () {
            return objNew(
              arrayMap(
                yield execObjectStore(objectStore, 'getAll'),
                ({k, v}) => [k, v],
              ),
            );
          }),
        );
      });
    const setPersisted = (getContent) =>
      __async(void 0, null, function* () {
        return yield forObjectStores(
          (objectStore, content) =>
            __async(void 0, null, function* () {
              return yield objectStoreMatch(objectStore, content);
            }),
          getContent(),
          1,
        );
      });
    const addPersisterListener = (listener) =>
      startInterval(listener, autoLoadIntervalSeconds);
    const delPersisterListener = (interval) => stopInterval(interval);
    return createCustomPersister(
      store,
      getPersisted,
      setPersisted,
      addPersisterListener,
      delPersisterListener,
      onIgnoredError,
      1,
      // StoreOnly,
      {getDbName: () => dbName},
    );
  };

  exports.createIndexedDbPersister = createIndexedDbPersister;
  exports.objectStoreMatch = objectStoreMatch;
});
