var t,a;t=this,a=function(t){"use strict";const a=t=>typeof t,e="tinybase",n="",s=",",i=a(n),r=Promise,o=clearInterval,c=t=>null==t,l=(t,a,e)=>c(t)?e?.():a(t),E=t=>a(t)==i,d=t=>Array.isArray(t),y=(t,a,e)=>t.slice(a,e),u=t=>t.length,w=async t=>r.all(t),T=t=>{throw Error(t)},R=(t,a)=>t.forEach(a),A=(t,a="")=>t.join(a),N=(t,a)=>t.map(a),g=t=>0==u(t),p=(t,a)=>t.filter(a),m=(t,...a)=>t.push(...a),O=t=>t.shift(),$=Object,C=t=>$.getPrototypeOf(t),v=$.entries,S=$.keys,f=$.freeze,L=(t=[])=>$.fromEntries(t),I=(...t)=>$.assign({},...t),_=(t,a)=>(delete t[a],t),h=(t,a)=>N(v(t),(([t,e])=>a(e,t))),b=(t,a)=>L(h(t,((t,e)=>[e,a(t,e)]))),P=t=>$.values(t),D=t=>u(S(t)),M=t=>(t=>!c(t)&&l(C(t),(t=>t==$.prototype||c(C(t))),(()=>!0)))(t)&&0==D(t),F=(t,a)=>t?.has(a)??!1,U=t=>c(t)||0==(t=>t?.size??0)(t),G=t=>[...t?.values()??[]],B=(t,a)=>t?.forEach(a),j=(t,a)=>t?.delete(a),x=t=>new Map(t),Y=(t,a)=>t?.get(a),q=(t,a)=>N([...t?.entries()??[]],(([t,e])=>a(e,t))),H=(t,a,e)=>c(e)?(j(t,a),t):t?.set(a,e),X=(t,a,e,n)=>(F(t,a)?n?.(Y(t,a)):H(t,a,e()),Y(t,a)),J=(t,a,e,n,s=0)=>l((e?X:Y)(t,a[s],s>u(a)-2?e:x),(i=>{if(s>u(a)-2)return n?.(i)&&H(t,a[s]),i;const r=J(i,a,e,n,s+1);return U(i)&&H(t,a[s]),r})),W=t=>new Set(d(t)||c(t)?t:[t]),k=(t,a)=>t?.add(a),z=/^\d+$/,K=x(),V=x(),Q=(t,a,e,s,i,r,o,E={},y=0,w=[])=>{let A,N,g,p=0,$=0,C=0;X(K,w,(()=>0)),X(V,w,(()=>[]));const v=x(),[S,L,I,_,h]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!M(t)||!M(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!M(t)||!M(a),a.setContent]:T("Store type not supported by this Persister"))(o,t,y),[b,P,D]=(()=>{let t;const[a,e]=(()=>{const t=[];let a=0;return[e=>(e?O(t):null)??n+a++,a=>{z.test(a)&&u(t)<1e3&&m(t,a)}]})(),s=x();return[(e,i,r,o=[],c=()=>[])=>{t??=et;const l=a(1);return H(s,l,[e,i,r,o,c]),k(J(i,r??[n],W),l),l},(a,e,...i)=>R(((t,a=[n])=>{const e=[],s=(t,n)=>n==u(a)?m(e,t):null===a[n]?B(t,(t=>s(t,n+1))):R([a[n],null],(a=>s(Y(t,a),n+1)));return s(t,0),e})(a,e),(a=>B(a,(a=>Y(s,a)[0](t,...e??[],...i))))),t=>l(Y(s,t),(([,a,i])=>(J(a,i??[n],void 0,(a=>(j(a,t),U(a)?1:0))),H(s,t),e(t),i))),a=>l(Y(s,a),(([a,,e=[],n,s])=>{const i=(...r)=>{const o=u(r);o==u(e)?a(t,...r,...s(r)):c(e[o])?R(n[o]?.(...r)??[],(t=>i(...r,t))):i(...r,e[o])};i()}))]})(),F=t=>{t!=p&&(p=t,P(v,void 0,p))},G=a=>{(S&&d(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},q=async t=>(2!=p&&(F(1),$++,await at((async()=>{try{const e=await a();d(e)?G(e):t?h(t):T("Content is not an array: "+e)}catch(a){r?.(a),t&&h(t)}F(0)}))),et),Q=()=>(N&&(i(N),N=void 0),et),Z=async t=>(1!=p&&(F(2),C++,await at((async()=>{try{await e(L,t)}catch(t){r?.(t)}F(0)}))),et),tt=()=>(g&&(t.delListener(g),g=void 0),et),at=async(...t)=>(m(Y(V,w),...t),await(async()=>{if(!Y(K,w)){for(H(K,w,1);!c(A=O(Y(V,w)));)try{await A()}catch(t){r?.(t)}H(K,w,0)}})(),et),et={load:q,startAutoLoad:async t=>{Q(),await q(t);try{N=await s((async(t,a)=>{a||t?2!=p&&(F(1),$++,G(a??t),F(0)):await q()}))}catch(t){r?.(t)}return et},stopAutoLoad:Q,isAutoLoading:()=>!c(N),save:Z,startAutoSave:async()=>(tt(),await Z(),g=t.addDidFinishTransactionListener((()=>{const t=I();_(t)&&Z(t)})),et),stopAutoSave:tt,isAutoSaving:()=>!c(g),getStatus:()=>p,addStatusListener:t=>b(t,v),delListener:a=>(D(a),t),schedule:at,getStore:()=>t,destroy:()=>(Y(V,w).splice(0,void 0),Q().stopAutoSave()),getStats:()=>({loads:$,saves:C}),...E};return f(et)},Z="_",tt="_id",at="SELECT",et="WHERE",nt="TABLE",st="ALTER "+nt,it="DELETE FROM",rt=at+"*FROM",ot="pragma_",ct="data_version",lt="schema_version",Et="pragma_table_",dt=(t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t,yt=t=>`"${t.replace(/"/g,'""')}"`,ut=(t,a=[1])=>A(N(t,(()=>"$"+a[0]++)),s),wt=JSON.stringify,Tt=JSON.parse,Rt=(t,a,e,n,i,r=At,o,l)=>{const E=x();return[async()=>{E.clear(),N(await e(t,a),(({tn:t,cn:a})=>k(X(E,t,W),a)))},async(a,e)=>((t,a)=>F(Y(E,t),a))(a,e)?L(p(N(await t(rt+yt(a)),(t=>[t[e],l?b(_(t,e),l):_(t,e)])),(([t,a])=>!c(t)&&!M(a)))):{},async(a,e,n,l,d,y=!1)=>{const u=W();b(n??{},(t=>N(S(t??{}),(t=>k(u,t)))));const T=G(u);if(!y&&d&&g(T)&&F(E,a))return await t("DROP "+nt+yt(a)),void H(E,a);const R=Y(E,a),O=W(G(R));if(g(T)||(F(E,a)?await w(N([e,...T],(async(n,s)=>{j(O,n)||(await t(st+yt(a)+"ADD"+yt(n)+i),0==s&&await t("CREATE UNIQUE INDEX pk ON "+yt(a)+`(${yt(e)})`),k(R,n))}))):(await t("CREATE "+nt+yt(a)+`(${yt(e)}${i} PRIMARY KEY${A(N(T,(t=>s+yt(t)+i)))});`),H(E,a,W([e,...T])))),await w([...!y&&l?N(G(O),(async n=>{n!=e&&(await t(st+yt(a)+"DROP"+yt(n)),j(R,n))})):[]]),y)c(n)?await t(it+yt(a)+et+" true"):await w(h(n,(async(n,s)=>{c(n)?await t(it+yt(a)+et+yt(e)+"=$1",[s]):g(T)||await r(t,a,e,S(n),{[s]:o?N(P(n),o):P(n)},R)})));else if(g(T))F(E,a)&&await t(it+yt(a)+et+" true");else{const s=p(G(Y(E,a)),(t=>t!=e)),i={},c=[];b(n??{},((t,a)=>{i[a]=N(s,(a=>o?o(t?.[a]):t?.[a])),m(c,a)})),await r(t,a,e,s,i),await t(it+yt(a)+et+yt(e)+`NOT IN(${ut(c)})`,c)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){n?.(t)}return await t("END"),e}]},At=async(t,a,e,n,i)=>{const r=[1];await t("INSERT INTO"+yt(a)+"("+((...t)=>A(N(t,yt),s))(e,...n)+")VALUES"+A(h(i,(t=>"($"+r[0]+++","+ut(t,r)+")")),s)+"ON CONFLICT("+yt(e)+")DO UPDATE SET"+A(N(n,(t=>yt(t)+"=excluded."+yt(t))),s),h(i,((t,a)=>[a,...N(t,(t=>t??null))])).flat())},Nt=(t,a,e,n,s,i,r,[o,c,l],E,d,y,u,w,T)=>{const[R,A,N,g]=Rt(a,E,d,s,w,T),p=Q(t,(async()=>await g((async()=>{return await R(),t=(await A(o,c))[Z]?.[l]??"null",Tt(t,((t,a)=>"￼"===a?void 0:a));var t}))),(async t=>await g((async()=>{var a;await R(),await N(o,c,{[Z]:{[l]:(a=t()??null,wt(a,((t,a)=>void 0===a?"￼":a)))}},!0,!0)}))),e,n,s,r,{[u]:()=>y,destroy:()=>(p.stopAutoLoad().stopAutoSave(),i(),p)},0,y);return p},gt=(t,a,e,n,s,i,r,[o,l,[E,d,y]],u,T,R,A,N,g,m,O)=>{const[$,C,v,S]=Rt(a,u,T,s,N,g,m,O),f=async(t,a)=>await w(q(l,(async([e,n,s,i],r)=>{a&&!(r in t)||await v(e,n,t[r],s,i,a)}))),I=async(t,a)=>d?await v(y,tt,{[Z]:t},!0,!0,a):null,_=Q(t,(async()=>await S((async()=>{await $();const t=await(async()=>L(p(await w(q(o,(async([t,a],e)=>[t,await C(e,a)]))),(t=>!M(t[1])))))(),a=await(async()=>E?(await C(y,tt))[Z]:{})();return M(t)&&c(a)?void 0:[t,a]}))),(async(t,a)=>await S((async()=>{if(await $(),c(a)){const[a,e]=t();await f(a),await I(e)}else await f(a[0],!0),await I(a[1],!0)}))),e,n,s,r,{[A]:()=>R,destroy:()=>(_.stopAutoLoad().stopAutoSave(),i(),_)},0,R);return _},pt="ColumnName",mt="store",Ot="json",$t=mt+"TableName",Ct=mt+"Id"+pt,vt=mt+pt,St="autoLoadIntervalSeconds",ft="rowId"+pt,Lt="tableId",It="tableName",_t="deleteEmptyColumns",ht="deleteEmptyTable",bt={mode:Ot,[St]:1},Pt={load:0,save:0,[It]:e+"_values"},Dt=(t,a,e,n,s)=>{const i=x();return b(t,((t,r)=>{const o=y(P(I(a,E(t)?{[e]:t}:t)),0,D(a));c(o[0])||n(r,o[0])||(s(r,o[0]),H(i,r,o))})),i},Mt=t=>{const a=(t=>I(bt,E(t)?{[$t]:t}:t??{}))(t),n=a[St];if(a.mode==Ot){const t=a[$t]??e;return[1,n,[t,a[Ct]??tt,a[vt]??mt],W(t)]}const{tables:{load:s={},save:i={}}={},values:r={}}=a,o=y(P(I(Pt,r)),0,D(Pt)),c=o[2],l=W(c),d=W(c);return[0,n,[Dt(s,{[Lt]:null,[ft]:tt},Lt,(t=>F(d,t)),(t=>k(l,t))),Dt(i,{[It]:null,[ft]:tt,[_t]:0,[ht]:0},It,((t,a)=>F(d,a)),((t,a)=>k(l,a))),o],l]},Ft=e,Ut=/^([cd]:)(.+)/,Gt=e+"_data",Bt=e+"_table";t.Persists={StoreOnly:1,MergeableStoreOnly:2,StoreOrMergeableStore:3},t.Status={Idle:0,Loading:1,Saving:2},t.createCustomPersister=Q,t.createCustomPostgreSqlPersister=(t,a,e,n,s,i,r,o,c,E,d="getDb")=>{const y=dt(e,i),[u,,T,R]=Mt(a),A=async t=>{await y(`CREATE OR REPLACE TRIGGER ${yt(Gt+"_"+t)} AFTER INSERT OR UPDATE OR DELETE ON ${yt(t)} EXECUTE FUNCTION ${Gt}()`)};return(u?Nt:gt)(t,y,(async t=>{await y(`CREATE OR REPLACE FUNCTION ${Bt}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Ft}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await y(`CREATE EVENT TRIGGER ${Bt} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${Bt}();`)}catch{}return await y(`CREATE OR REPLACE FUNCTION ${Gt}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Ft}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(N(G(R),(async t=>{await y(`CREATE TABLE IF NOT EXISTS ${yt(t)}("_id"text PRIMARY KEY)`),await A(t)}))),await n(Ft,(async a=>{return await l((e=a,n=Ut,e?.match(n)),(async([,a,e])=>{F(R,e)&&("c:"==a&&await A(e),t())}));var e,n}))}),s,r,o,c,T,G(R),(async(t,a)=>await t(`${at} table_name tn,column_name cn FROM information_schema.columns ${et} table_schema='public'AND table_name IN(${ut(a)})`,a)),E,d,"text",void 0,(t=>wt(t)),(t=>Tt(t)))},t.createCustomSqlitePersister=(t,a,e,s,i,r,c,l,E,d,y="getDb",u)=>{let w,T,R;const A=dt(e,r),[N,g,p,m]=Mt(a);return(N?Nt:gt)(t,A,(t=>{let a;const e=()=>a=setInterval((async()=>{try{const[{d:a,s:e,c:n}]=await A(`${at} ${ct} d,${lt} s,TOTAL_CHANGES() c FROM ${ot}${ct} JOIN ${ot}${lt}`);a==w&&e==T&&n==R||(null!=w&&t(),w=a,T=e,R=n)}catch{}}),1e3*g),n=()=>{w=T=R=null,o(a)},r=s((a=>{m.has(a)&&(n(),t(),e())}));return e(),()=>{n(),i(r)}}),(t=>t()),c,l,E,p,G(m),(async(t,a)=>await t(`${at} t.name tn,c.name cn FROM ${Et}list()t,${Et}info(t.name)c ${et} t.schema='main'AND t.type IN('table','view')AND t.name IN(${ut(a)})ORDER BY t.name,c.name`,a)),d,y,n,u,(t=>!0===t?1:!1===t?0:t),void 0)}},"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisters={});
