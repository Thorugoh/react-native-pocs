var e,t;e=this,t=function(e){"use strict";const t=Promise,a=globalThis.window,n=clearInterval,s=e=>null==e,r=(e,t,a)=>s(e)?a?.():t(e),o=e=>Array.isArray(e),c=e=>e.length,i=e=>new t(e),l=async e=>t.all(e),d=e=>{throw Error(e)},y=(e,t)=>e.forEach(t),u=(e,t)=>e.map(t),g=(e,...t)=>e.push(...t),p=e=>e.shift(),h=Object,w=e=>h.getPrototypeOf(e),f=h.entries,v=h.keys,b=h.freeze,S=e=>(e=>!s(e)&&r(w(e),(e=>e==h.prototype||s(w(e))),(()=>!0)))(e)&&0==(e=>c(v(e)))(e),A=e=>s(e)||0==(e=>e?.size??0)(e),C=(e,t)=>e?.forEach(t),x=(e,t)=>e?.delete(t),D=e=>new Map(e),L=(e,t)=>e?.get(t),M=(e,t,a)=>s(a)?(x(e,t),e):e?.set(t,a),T=(e,t,a,n)=>{var s,r;return s=e,r=t,s?.has(r)?n?.(L(e,t)):M(e,t,a()),L(e,t)},j=(e,t,a,n,s=0)=>r((a?T:L)(e,t[s],s>c(t)-2?a:D),(r=>{if(s>c(t)-2)return n?.(r)&&M(e,t[s]),r;const o=j(r,t,a,n,s+1);return A(r)&&M(e,t[s]),o})),m=e=>new Set(o(e)||s(e)?e:[e]),P=/^\d+$/,k=D(),B=D(),E=(e,t,a,n,i,l,u,h={},w=0,f=[])=>{let v,E,I,O=0,z=0,$=0;T(k,f,(()=>0)),T(B,f,(()=>[]));const F=D(),[K,N,q,G,H]=((e=1,t,a)=>1!=e&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!a),([[e],[t]])=>!S(e)||!S(t),t.setDefaultContent]:2!=e?[0,t.getContent,t.getTransactionChanges,([e,t])=>!S(e)||!S(t),t.setContent]:d("Store type not supported by this Persister"))(u,e,w),[J,Q,R]=(()=>{let e;const[t,a]=(()=>{const e=[];let t=0;return[a=>(a?p(e):null)??""+t++,t=>{P.test(t)&&c(e)<1e3&&g(e,t)}]})(),n=D();return[(a,s,r,o=[],c=()=>[])=>{e??=ee;const i=t(1);var l,d;return M(n,i,[a,s,r,o,c]),l=j(s,r??[""],m),d=i,l?.add(d),i},(t,a,...s)=>y(((e,t=[""])=>{const a=[],n=(e,s)=>s==c(t)?g(a,e):null===t[s]?C(e,(e=>n(e,s+1))):y([t[s],null],(t=>n(L(e,t),s+1)));return n(e,0),a})(t,a),(t=>C(t,(t=>L(n,t)[0](e,...a??[],...s))))),e=>r(L(n,e),(([,t,s])=>(j(t,s??[""],void 0,(t=>(x(t,e),A(t)?1:0))),M(n,e),a(e),s))),t=>r(L(n,t),(([t,,a=[],n,r])=>{const o=(...i)=>{const l=c(i);l==c(a)?t(e,...i,...r(i)):s(a[l])?y(n[l]?.(...i)??[],(e=>o(...i,e))):o(...i,a[l])};o()}))]})(),U=e=>{e!=O&&(O=e,Q(F,void 0,O))},V=t=>{(K&&o(t?.[0])?1===t?.[2]?e.applyMergeableChanges:e.setMergeableContent:1===t?.[2]?e.applyChanges:e.setContent)(t)},W=async e=>(2!=O&&(U(1),z++,await _((async()=>{try{const a=await t();o(a)?V(a):e?H(e):d("Content is not an array: "+a)}catch(t){l?.(t),e&&H(e)}U(0)}))),ee),X=()=>(E&&(i(E),E=void 0),ee),Y=async e=>(1!=O&&(U(2),$++,await _((async()=>{try{await a(N,e)}catch(e){l?.(e)}U(0)}))),ee),Z=()=>(I&&(e.delListener(I),I=void 0),ee),_=async(...e)=>(g(L(B,f),...e),await(async()=>{if(!L(k,f)){for(M(k,f,1);!s(v=p(L(B,f)));)try{await v()}catch(e){l?.(e)}M(k,f,0)}})(),ee),ee={load:W,startAutoLoad:async e=>{X(),await W(e);try{E=await n((async(e,t)=>{t||e?2!=O&&(U(1),z++,V(t??e),U(0)):await W()}))}catch(e){l?.(e)}return ee},stopAutoLoad:X,isAutoLoading:()=>!s(E),save:Y,startAutoSave:async()=>(Z(),await Y(),I=e.addDidFinishTransactionListener((()=>{const e=q();G(e)&&Y(e)})),ee),stopAutoSave:Z,isAutoSaving:()=>!s(I),getStatus:()=>O,addStatusListener:e=>J(e,F),delListener:t=>(R(t),e),schedule:_,getStore:()=>e,destroy:()=>(L(B,f).splice(0,void 0),X().stopAutoSave()),getStats:()=>({loads:z,saves:$}),...h};return b(ee)},I=["t","v"],O={keyPath:"k"},z=async(e,t)=>{const a=(t=>u(f(t),(([t,a])=>$(e,"put",{k:t,v:a}))))(t);u(await $(e,"getAllKeys"),(n=>((e,t)=>t in e)(t,n)?0:g(a,$(e,"delete",n)))),await l(a)},$=async(e,t,a)=>i(((n,s)=>{const r=e[t](a);r.onsuccess=()=>n(r.result),r.onerror=()=>s(`objectStore.${t} error`)}));e.createIndexedDbPersister=(e,t,s=1,r)=>{const o=async(e,n=[],s=0)=>i(((r,o)=>{const c=(a?a.indexedDB:indexedDB).open(t,s?2:void 0);c.onupgradeneeded=()=>s&&u(I,(e=>{try{c.result.createObjectStore(e,O)}catch{}})),c.onsuccess=async()=>{try{const t=c.result.transaction(I,"readwrite"),a=await l(u(I,(async(a,s)=>await e(t.objectStore(a),n[s]))));c.result.close(),r(a)}catch(e){c.result.close(),o(e)}},c.onerror=()=>o("indexedDB.open error")}));return E(e,(async()=>await o((async e=>((e=[])=>h.fromEntries(e))(u(await $(e,"getAll"),(({k:e,v:t})=>[e,t])))))),(async e=>await o((async(e,t)=>await z(e,t)),e(),1)),(e=>setInterval(e,1e3*s)),(e=>n(e)),r,1,{getDbName:()=>t})},e.objectStoreMatch=z},"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).TinyBasePersisterIndexedDb={});
