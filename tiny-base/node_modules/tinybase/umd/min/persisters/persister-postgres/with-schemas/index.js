var t,a;t=this,a=function(t){"use strict";const a=t=>typeof t,e="tinybase",n=",",s=a(""),i=Promise,o=t=>null==t,r=(t,a,e)=>o(t)?e?.():a(t),c=t=>a(t)==s,l=t=>Array.isArray(t),E=(t,a,e)=>t.slice(a,e),y=t=>t.length,w=async t=>i.all(t),d=t=>{throw Error(t)},u=(t,a)=>t.forEach(a),T=(t,a="")=>t.join(a),R=(t,a)=>t.map(a),A=t=>0==y(t),N=(t,a)=>t.filter(a),g=(t,...a)=>t.push(...a),p=t=>t.shift(),C="_",f="_id",O="SELECT",L="WHERE",v="TABLE",$="ALTER "+v,m="DELETE FROM",S=O+"*FROM",I=t=>`"${t.replace(/"/g,'""')}"`,h=(t,a=[1])=>T(R(t,(()=>"$"+a[0]++)),n),_=(t,a)=>t?.has(a)??!1,b=t=>o(t)||0==(t=>t?.size??0)(t),P=t=>[...t?.values()??[]],D=(t,a)=>t?.forEach(a),U=(t,a)=>t?.delete(a),F=Object,M=t=>F.getPrototypeOf(t),G=F.entries,B=F.keys,j=F.freeze,x=(t=[])=>F.fromEntries(t),X=(...t)=>F.assign({},...t),Y=(t,a)=>(delete t[a],t),q=(t,a)=>R(G(t),(([t,e])=>a(e,t))),H=(t,a)=>x(q(t,((t,e)=>[e,a(t,e)]))),W=t=>F.values(t),k=t=>y(B(t)),z=t=>(t=>!o(t)&&r(M(t),(t=>t==F.prototype||o(M(t))),(()=>!0)))(t)&&0==k(t),J=JSON.stringify,K=JSON.parse,V=t=>new Map(t),Q=(t,a)=>t?.get(a),Z=(t,a)=>R([...t?.entries()??[]],(([t,e])=>a(e,t))),tt=(t,a,e)=>o(e)?(U(t,a),t):t?.set(a,e),at=(t,a,e,n)=>(_(t,a)?n?.(Q(t,a)):tt(t,a,e()),Q(t,a)),et=(t,a,e,n,s=0)=>r((e?at:Q)(t,a[s],s>y(a)-2?e:V),(i=>{if(s>y(a)-2)return n?.(i)&&tt(t,a[s]),i;const o=et(i,a,e,n,s+1);return b(i)&&tt(t,a[s]),o})),nt=t=>new Set(l(t)||o(t)?t:[t]),st=(t,a)=>t?.add(a),it=/^\d+$/,ot=V(),rt=V(),ct=(t,a,e,n,s,i,c,E={},w=0,T=[])=>{let R,A,N,C=0,f=0,O=0;at(ot,T,(()=>0)),at(rt,T,(()=>[]));const L=V(),[v,$,m,S,I]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!z(t)||!z(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!z(t)||!z(a),a.setContent]:d("Store type not supported by this Persister"))(c,t,w),[h,_,P]=(()=>{let t;const[a,e]=(()=>{const t=[];let a=0;return[e=>(e?p(t):null)??""+a++,a=>{it.test(a)&&y(t)<1e3&&g(t,a)}]})(),n=V();return[(e,s,i,o=[],r=()=>[])=>{t??=q;const c=a(1);return tt(n,c,[e,s,i,o,r]),st(et(s,i??[""],nt),c),c},(a,e,...s)=>u(((t,a=[""])=>{const e=[],n=(t,s)=>s==y(a)?g(e,t):null===a[s]?D(t,(t=>n(t,s+1))):u([a[s],null],(a=>n(Q(t,a),s+1)));return n(t,0),e})(a,e),(a=>D(a,(a=>Q(n,a)[0](t,...e??[],...s))))),t=>r(Q(n,t),(([,a,s])=>(et(a,s??[""],void 0,(a=>(U(a,t),b(a)?1:0))),tt(n,t),e(t),s))),a=>r(Q(n,a),(([a,,e=[],n,s])=>{const i=(...r)=>{const c=y(r);c==y(e)?a(t,...r,...s(r)):o(e[c])?u(n[c]?.(...r)??[],(t=>i(...r,t))):i(...r,e[c])};i()}))]})(),F=t=>{t!=C&&(C=t,_(L,void 0,C))},M=a=>{(v&&l(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},G=async t=>(2!=C&&(F(1),f++,await Y((async()=>{try{const e=await a();l(e)?M(e):t?I(t):d("Content is not an array: "+e)}catch(a){i?.(a),t&&I(t)}F(0)}))),q),B=()=>(A&&(s(A),A=void 0),q),x=async t=>(1!=C&&(F(2),O++,await Y((async()=>{try{await e($,t)}catch(t){i?.(t)}F(0)}))),q),X=()=>(N&&(t.delListener(N),N=void 0),q),Y=async(...t)=>(g(Q(rt,T),...t),await(async()=>{if(!Q(ot,T)){for(tt(ot,T,1);!o(R=p(Q(rt,T)));)try{await R()}catch(t){i?.(t)}tt(ot,T,0)}})(),q),q={load:G,startAutoLoad:async t=>{B(),await G(t);try{A=await n((async(t,a)=>{a||t?2!=C&&(F(1),f++,M(a??t),F(0)):await G()}))}catch(t){i?.(t)}return q},stopAutoLoad:B,isAutoLoading:()=>!o(A),save:x,startAutoSave:async()=>(X(),await x(),N=t.addDidFinishTransactionListener((()=>{const t=m();S(t)&&x(t)})),q),stopAutoSave:X,isAutoSaving:()=>!o(N),getStatus:()=>C,addStatusListener:t=>h(t,L),delListener:a=>(P(a),t),schedule:Y,getStore:()=>t,destroy:()=>(Q(rt,T).splice(0,void 0),B().stopAutoSave()),getStats:()=>({loads:f,saves:O}),...E};return j(q)},lt=(t,a,e,s,i,r=Et,c,l)=>{const E=V();return[async()=>{E.clear(),R(await e(t,a),(({tn:t,cn:a})=>st(at(E,t,nt),a)))},async(a,e)=>((t,a)=>_(Q(E,t),a))(a,e)?x(N(R(await t(S+I(a)),(t=>[t[e],l?H(Y(t,e),l):Y(t,e)])),(([t,a])=>!o(t)&&!z(a)))):{},async(a,e,s,l,y,d=!1)=>{const u=nt();H(s??{},(t=>R(B(t??{}),(t=>st(u,t)))));const p=P(u);if(!d&&y&&A(p)&&_(E,a))return await t("DROP "+v+I(a)),void tt(E,a);const C=Q(E,a),f=nt(P(C));if(A(p)||(_(E,a)?await w(R([e,...p],(async(n,s)=>{U(f,n)||(await t($+I(a)+"ADD"+I(n)+i),0==s&&await t("CREATE UNIQUE INDEX pk ON "+I(a)+`(${I(e)})`),st(C,n))}))):(await t("CREATE "+v+I(a)+`(${I(e)}${i} PRIMARY KEY${T(R(p,(t=>n+I(t)+i)))});`),tt(E,a,nt([e,...p])))),await w([...!d&&l?R(P(f),(async n=>{n!=e&&(await t($+I(a)+"DROP"+I(n)),U(C,n))})):[]]),d)o(s)?await t(m+I(a)+L+" true"):await w(q(s,(async(n,s)=>{o(n)?await t(m+I(a)+L+I(e)+"=$1",[s]):A(p)||await r(t,a,e,B(n),{[s]:c?R(W(n),c):W(n)},C)})));else if(A(p))_(E,a)&&await t(m+I(a)+L+" true");else{const n=N(P(Q(E,a)),(t=>t!=e)),i={},o=[];H(s??{},((t,a)=>{i[a]=R(n,(a=>c?c(t?.[a]):t?.[a])),g(o,a)})),await r(t,a,e,n,i),await t(m+I(a)+L+I(e)+`NOT IN(${h(o)})`,o)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){s?.(t)}return await t("END"),e}]},Et=async(t,a,e,s,i)=>{const o=[1];await t("INSERT INTO"+I(a)+"("+((...t)=>T(R(t,I),n))(e,...s)+")VALUES"+T(q(i,(t=>"($"+o[0]+++","+h(t,o)+")")),n)+"ON CONFLICT("+I(e)+")DO UPDATE SET"+T(R(s,(t=>I(t)+"=excluded."+I(t))),n),q(i,((t,a)=>[a,...R(t,(t=>t??null))])).flat())},yt=(t,a,e,n,s,i,o,[r,c,l],E,y,w,d,u,T)=>{const[R,A,N,g]=lt(a,E,y,s,u,T),p=ct(t,(async()=>await g((async()=>{return await R(),t=(await A(r,c))[C]?.[l]??"null",K(t,((t,a)=>"￼"===a?void 0:a));var t}))),(async t=>await g((async()=>{var a;await R(),await N(r,c,{[C]:{[l]:(a=t()??null,J(a,((t,a)=>void 0===a?"￼":a)))}},!0,!0)}))),e,n,s,o,{[d]:()=>w,destroy:()=>(p.stopAutoLoad().stopAutoSave(),i(),p)},0,w);return p},wt=(t,a,e,n,s,i,r,[c,l,[E,y,d]],u,T,R,A,g,p,O,L)=>{const[v,$,m,S]=lt(a,u,T,s,g,p,O,L),I=async(t,a)=>await w(Z(l,(async([e,n,s,i],o)=>{a&&!(o in t)||await m(e,n,t[o],s,i,a)}))),h=async(t,a)=>y?await m(d,f,{[C]:t},!0,!0,a):null,_=ct(t,(async()=>await S((async()=>{await v();const t=await(async()=>x(N(await w(Z(c,(async([t,a],e)=>[t,await $(e,a)]))),(t=>!z(t[1])))))(),a=await(async()=>E?(await $(d,f))[C]:{})();return z(t)&&o(a)?void 0:[t,a]}))),(async(t,a)=>await S((async()=>{if(await v(),o(a)){const[a,e]=t();await I(a),await h(e)}else await I(a[0],!0),await h(a[1],!0)}))),e,n,s,r,{[A]:()=>R,destroy:()=>(_.stopAutoLoad().stopAutoSave(),i(),_)},0,R);return _},dt="ColumnName",ut="store",Tt="json",Rt=ut+"TableName",At=ut+"Id"+dt,Nt=ut+dt,gt="autoLoadIntervalSeconds",pt="rowId"+dt,Ct="tableId",ft="tableName",Ot="deleteEmptyColumns",Lt="deleteEmptyTable",vt={mode:Tt,[gt]:1},$t={load:0,save:0,[ft]:e+"_values"},mt=(t,a,e,n,s)=>{const i=V();return H(t,((t,r)=>{const l=E(W(X(a,c(t)?{[e]:t}:t)),0,k(a));o(l[0])||n(r,l[0])||(s(r,l[0]),tt(i,r,l))})),i},St=e,It=/^([cd]:)(.+)/,ht=e+"_data",_t=e+"_table";t.createPostgresPersister=async(t,a,n,s,i)=>{const o=await(a.reserve?.());return((t,a,n,s,i,o,l,y,d,u,T="getDb")=>{const A=((t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t)(n,o),[N,,g,p]=(t=>{const a=(t=>X(vt,c(t)?{[Rt]:t}:t??{}))(t),n=a[gt];if(a.mode==Tt){const t=a[Rt]??e;return[1,n,[t,a[At]??f,a[Nt]??ut],nt(t)]}const{tables:{load:s={},save:i={}}={},values:o={}}=a,r=E(W(X($t,o)),0,k($t)),l=r[2],y=nt(l),w=nt(l);return[0,n,[mt(s,{[Ct]:null,[pt]:f},Ct,(t=>_(w,t)),(t=>st(y,t))),mt(i,{[ft]:null,[pt]:f,[Ot]:0,[Lt]:0},ft,((t,a)=>_(w,a)),((t,a)=>st(y,a))),r],y]})(a),C=async t=>{await A(`CREATE OR REPLACE TRIGGER ${I(ht+"_"+t)} AFTER INSERT OR UPDATE OR DELETE ON ${I(t)} EXECUTE FUNCTION ${ht}()`)};return(N?yt:wt)(t,A,(async t=>{await A(`CREATE OR REPLACE FUNCTION ${_t}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${St}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await A(`CREATE EVENT TRIGGER ${_t} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${_t}();`)}catch{}return await A(`CREATE OR REPLACE FUNCTION ${ht}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${St}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(R(P(p),(async t=>{await A(`CREATE TABLE IF NOT EXISTS ${I(t)}("_id"text PRIMARY KEY)`),await C(t)}))),await s(St,(async a=>{return await r((e=a,n=It,e?.match(n)),(async([,a,e])=>{_(p,e)&&("c:"==a&&await C(e),t())}));var e,n}))}),i,l,y,d,g,P(p),(async(t,a)=>await t(`${O} table_name tn,column_name cn FROM information_schema.columns ${L} table_schema='public'AND table_name IN(${h(a)})`,a)),u,T,"text",void 0,(t=>J(t)),(t=>K(t)))})(t,n,o?.unsafe,(async(t,e)=>a.listen(t,e)),(async t=>{try{await t.unlisten()}catch(t){i?.(t)}}),s,i,(()=>o?.release?.()),3,a,"getSql")}},"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisterPostgres={});
